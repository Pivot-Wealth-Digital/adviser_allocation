{% extends "layout.html" %}
{% set title = "Box Collaborator Lookup" %}

{% block content %}
<div class="topbar">
  <div style="display:flex;align-items:center;gap:16px;">
    <a href="/" style="color:#d0d7e2;text-decoration:none;font-size:0.9em;">← Home</a>
    <h2>Box Collaborator Lookup</h2>
  </div>
  <div class="datebox">
    <span>Status:</span>
    <span id="status-text" class="muted">Awaiting folder id</span>
  </div>
</div>

<div class="card lookup-card">
  <p class="muted small">
    Enter a Box <code>folder_id</code>, optionally inspect subfolders, and review collaborator access.
    External emails (outside <code>@pivotwealth.com.au</code>) are highlighted.
  </p>
  <form id="collab-form" class="collab-form">
    <label class="field">
      <span>Folder ID</span>
      <input type="text" id="folder-id" autocomplete="off" required />
    </label>
    <div class="actions root-actions">
      <button type="button" class="secondary" id="suggest-folder">Find Untagged Folder</button>
      <button type="button" class="primary" id="root-show" data-default="Show Collaborators">Show Collaborators</button>
      <button type="button" class="secondary" id="reset-btn">Cancel</button>
    </div>
    <div class="muted small suggestion-note" id="folder-suggestion-note"></div>
    <div class="suggestion-actions" id="folder-suggestion-actions">
      <button type="button" class="secondary" id="load-subfolders" data-default="Display Subfolders">Display Subfolders</button>
      <button type="button" class="secondary hidden" id="load-more-suggestions" data-default="Show Next 5">Show Next 5</button>
    </div>
    <div id="subfolder-wrapper" class="subfolder-wrapper hidden">
      <h3>Subfolders</h3>
      <p class="muted small" id="subfolder-empty">No subfolders loaded.</p>
      <div id="subfolder-list" class="subfolder-list hidden"></div>
      <div id="subfolder-actions" class="subfolder-actions hidden">
        <button type="button" class="primary" id="subfolder-show" data-default="Show Collaborators">Show Collaborators</button>
      </div>
    </div>
  </form>
</div>

<div id="external-card" class="card hidden">
  <h3>External Emails</h3>
  <p class="muted small" id="external-empty">No external collaborators detected.</p>
  <ul id="external-list" class="external-list hidden"></ul>
</div>

<div id="results-wrapper" class="card hidden">
  <h3>Collaborators</h3>
  <p class="muted small" id="summary-target"></p>
  <p><strong>Total collaborators:</strong> <span id="collab-total">0</span></p>
  <p><strong>External collaborators:</strong> <span id="external-total">0</span></p>

  <div class="table-wrapper">
    <table>
      <thead>
        <tr>
          <th>Email</th>
          <th>Name</th>
          <th>Role</th>
          <th>Status</th>
          <th>HubSpot</th>
        </tr>
      </thead>
      <tbody id="collab-table-body">
        <tr><td colspan="5" class="muted">No results yet.</td></tr>
      </tbody>
    </table>
  </div>
</div>

<div id="contact-card" class="card hidden">
  <h3>HubSpot Contact Details</h3>
  <div id="contact-details" class="contact-details muted small">
    Select a collaborator to load HubSpot details.
  </div>
  <div id="deal-card" class="contact-deals hidden">
    <div class="deal-header">
      <div>
        <h4>Associated Deals</h4>
        <p class="muted small" id="deal-message">Tick the checkbox next to a deal to load metadata values.</p>
      </div>
      <div class="muted small" id="folder-summary"></div>
    </div>
    <div id="deal-list" class="deal-list"></div>
  </div>
  <div id="metadata-actions" class="contact-actions hidden">
    <button type="button" class="secondary" id="metadata-preview-btn" data-default="Preview Metadata">
      Preview Metadata
    </button>
    <button
      type="button"
      class="secondary"
      id="deal-box-url-btn"
      data-default="Update Deal Box URL"
      data-deal-property="{{ hubspot_deal_property or '' }}"
    >
      Update Deal Box URL
    </button>
    <button type="button" class="primary" id="metadata-create-btn" data-default="Create Box Metadata">
      Create Box Metadata
    </button>
    <p id="metadata-status" class="muted small"></p>
    <div id="metadata-warning-list" class="warning-list hidden"></div>
    <div id="metadata-preview" class="metadata-preview hidden">
      <h4 class="muted small">Metadata preview</h4>
      <pre id="metadata-preview-content"></pre>
    </div>
  </div>
</div>

<div id="error-card" class="card error-card hidden"></div>

{% endblock %}

{% block head %}
<style>
  .lookup-card {
    margin-bottom: 20px;
  }

  .collab-form {
    display: grid;
    gap: 12px;
    max-width: 420px;
  }

  .field {
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-weight: 600;
  }

  .field span {
    font-size: 0.85em;
    color: #5a6578;
    font-weight: 500;
  }

  .actions,
  .subfolder-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .subfolder-wrapper {
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 12px;
    padding: 14px;
    background: rgba(15, 23, 42, 0.02);
    display: grid;
    gap: 10px;
  }

  .subfolder-list {
    display: grid;
    gap: 6px;
  }

  .subfolder-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.015);
  }

  .subfolder-item span {
    font-size: 0.85em;
    color: #52606d;
  }

  .suggestion-note {
    min-height: 1.2em;
  }

  .suggestion-list {
    display: grid;
    gap: 6px;
    margin-top: 8px;
  }

  .suggestion-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 8px 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.015);
  }

  .suggestion-item input[type="checkbox"] {
    margin-top: 3px;
  }

  .suggestion-item.highlight {
    border-color: rgba(16, 185, 129, 0.65);
    background: rgba(16, 185, 129, 0.08);
  }

  .suggestion-issues {
    margin: 6px 0 0 0;
    padding-left: 18px;
    font-size: 0.8em;
    line-height: 1.3;
  }

  .suggestion-issues-wrapper {
    margin-top: 8px;
    font-size: 0.8em;
  }

  .suggestion-issues-wrapper.hidden {
    display: none;
  }

  .suggestion-actions {
    margin-top: 8px;
  }

  .suggestion-actions button {
    margin-top: 4px;
  }

  .table-wrapper {
    overflow-x: auto;
  }

  table {
    width: 100%;
    border-collapse: collapse;
  }

  th,
  td {
    text-align: left;
    padding: 8px 10px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.35);
    font-size: 0.9em;
  }

  tr.external td {
    background: rgba(239, 68, 68, 0.12);
    color: #7f1d1d;
    font-weight: 600;
  }

  .external-list {
    list-style: disc;
    padding-left: 20px;
    display: grid;
    gap: 6px;
  }

  .deal-list {
    display: grid;
    gap: 6px;
    margin-top: 10px;
  }

  .deal-header {
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }

  .deal-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    padding: 10px 12px;
    background: rgba(15, 23, 42, 0.015);
  }

  .deal-item input[type="checkbox"] {
    margin-top: 4px;
    flex-shrink: 0;
  }

  .deal-item label {
    flex: 1;
    cursor: pointer;
  }

  .deal-item.highlight {
    border-color: rgba(79, 70, 229, 0.55);
    background: rgba(79, 70, 229, 0.08);
  }

  .deal-item .deal-badge {
    display: inline-block;
    margin-top: 6px;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 0.72em;
    font-weight: 600;
    background: rgba(249, 115, 22, 0.18);
    color: #9a3412;
  }

  .pivot-toggle {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85em;
    color: #52606d;
    margin-bottom: 12px;
  }

  .contact-details {
    display: grid;
    gap: 10px;
  }

  .contact-deals {
    display: grid;
    gap: 6px;
    margin-top: 10px;
  }

  .contact-details table {
    width: 100%;
    border-collapse: collapse;
  }

  .contact-details th,
  .contact-details td {
    text-align: left;
    padding: 6px 8px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.35);
  }

  .contact-actions {
    margin-top: 12px;
    display: grid;
    gap: 6px;
  }

  .contact-actions button {
    width: fit-content;
  }

  .warning-list {
    margin-top: 4px;
    padding: 8px 10px;
    border-left: 3px solid #f97316;
    background: rgba(249, 115, 22, 0.12);
    color: #92400e;
    font-size: 0.8em;
    display: grid;
    gap: 6px;
  }

  .warning-list.hidden {
    display: none;
  }

  .warning-list ul {
    margin: 0;
    padding-left: 18px;
  }

  .warning-list li {
    margin: 0;
  }

  .metadata-preview {
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    padding: 10px;
    background: rgba(15, 23, 42, 0.02);
    max-width: 420px;
  }

  .metadata-preview pre {
    margin: 6px 0 0 0;
    font-size: 0.82em;
    max-height: 220px;
    overflow: auto;
  }

  .hubspot-btn {
    font-size: 0.8em;
    padding: 4px 10px;
  }

  .error-card {
    border: 1px solid rgba(239, 68, 68, 0.35);
    color: #991b1b;
    background: rgba(239, 68, 68, 0.1);
    margin-top: 16px;
  }

</style>
{% endblock %}

{% block scripts %}
<script>
  const folderInput = document.getElementById('folder-id');
  const loadSubfoldersButton = document.getElementById('load-subfolders');
  const rootShowButton = document.getElementById('root-show');
  const resetButton = document.getElementById('reset-btn');
  const subfolderWrapper = document.getElementById('subfolder-wrapper');
  const subfolderList = document.getElementById('subfolder-list');
  const subfolderEmpty = document.getElementById('subfolder-empty');
  const subfolderActions = document.getElementById('subfolder-actions');
  const subfolderShowButton = document.getElementById('subfolder-show');
  const folderSuggestionNote = document.getElementById('folder-suggestion-note');
  const suggestionActions = document.getElementById('folder-suggestion-actions');
  const loadMoreSuggestionsButton = document.getElementById('load-more-suggestions');

  const statusText = document.getElementById('status-text');
  const resultsWrapper = document.getElementById('results-wrapper');
  const collabTotal = document.getElementById('collab-total');
  const externalTotal = document.getElementById('external-total');
  const summaryTarget = document.getElementById('summary-target');
  const collabTableBody = document.getElementById('collab-table-body');
  const externalCard = document.getElementById('external-card');
  const externalList = document.getElementById('external-list');
  const externalEmpty = document.getElementById('external-empty');
  const suggestFolderButton = document.getElementById('suggest-folder');
  const dealCard = document.getElementById('deal-card');
  const dealList = document.getElementById('deal-list');
  const dealMessage = document.getElementById('deal-message');
  const folderSummary = document.getElementById('folder-summary');
  const errorCard = document.getElementById('error-card');
  const contactCard = document.getElementById('contact-card');
  const contactDetails = document.getElementById('contact-details');
  const metadataActions = document.getElementById('metadata-actions');
  const metadataPreviewButton = document.getElementById('metadata-preview-btn');
  const metadataDealButton = document.getElementById('deal-box-url-btn');
  const dealPropertyName = metadataDealButton ? (metadataDealButton.dataset.dealProperty || '').trim() : '';
  const metadataButton = document.getElementById('metadata-create-btn');
  const metadataStatus = document.getElementById('metadata-status');
  const metadataWarningList = document.getElementById('metadata-warning-list');
  const metadataPreview = document.getElementById('metadata-preview');
  const metadataPreviewContent = document.getElementById('metadata-preview-content');
  const searchParams = new URLSearchParams(window.location.search);
  const presetFolderId = (searchParams.get('folder_id') || '').trim();
  const shouldAutoLoadSubfolders = Boolean(presetFolderId);
  if (presetFolderId && folderInput) {
    folderInput.value = presetFolderId;
    folderInput.focus();
  }

  let selectedSubfolderId = null;
  let selectedSubfolderName = null;
  let currentFolderId = '';
  let lastCollabResponse = null;
  let lastContactData = null;
  let rootFolderId = '';
  let currentDealList = [];
  let currentSelectedDeal = null;
  let currentFolderSuggestions = [];
  let currentSuggestionCursor = null;
  let currentContactWarnings = new Map();
  let currentFolderInfo = {};

  function setBusy(button, busy, label) {
    if (!button) return;
    if (busy) {
      button.dataset.default = button.dataset.default || button.textContent;
      button.textContent = label;
      button.disabled = true;
    } else {
      button.textContent = button.dataset.default || 'Submit';
      button.disabled = false;
    }
  }

  function resetUI() {
    resultsWrapper.classList.add('hidden');
    externalCard.classList.add('hidden');
    errorCard.classList.add('hidden');
    contactCard.classList.add('hidden');
    if (metadataActions) {
      metadataActions.classList.add('hidden');
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    collabTableBody.innerHTML = '<tr><td colspan="5" class="muted">No results yet.</td></tr>';
    externalList.innerHTML = '';
    externalList.classList.add('hidden');
    externalEmpty.classList.remove('hidden');
    if (folderSuggestionNote) folderSuggestionNote.innerHTML = '';
    if (suggestionActions) suggestionActions.classList.remove('hidden');
    if (loadSubfoldersButton) {
      loadSubfoldersButton.disabled = false;
      const defaultLabel = loadSubfoldersButton.dataset.default || 'Display Subfolders';
      loadSubfoldersButton.textContent = defaultLabel;
    }
    if (loadMoreSuggestionsButton) {
      loadMoreSuggestionsButton.classList.add('hidden');
      loadMoreSuggestionsButton.disabled = false;
      loadMoreSuggestionsButton.textContent = loadMoreSuggestionsButton.dataset.default || 'Show Next 5';
    }
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
    if (dealCard) dealCard.classList.add('hidden');
    collabTotal.textContent = '0';
    externalTotal.textContent = '0';
    statusText.textContent = 'Awaiting folder id';
    summaryTarget.textContent = '';
    subfolderList.innerHTML = '';
    subfolderList.classList.add('hidden');
    subfolderEmpty.classList.remove('hidden');
    subfolderWrapper.classList.add('hidden');
    subfolderActions.classList.add('hidden');
    selectedSubfolderId = null;
    selectedSubfolderName = null;
    currentFolderId = '';
    lastCollabResponse = null;
    lastContactData = null;
    currentDealList = [];
    currentSelectedDeal = null;
    rootFolderId = '';
    currentFolderSuggestions = [];
    currentSuggestionCursor = null;
    if (metadataStatus) {
      metadataStatus.textContent = '';
    }
    updateSuggestionNavigation(null);
    updateDealButtonState();
  }

  async function fetchJSON(url, options) {
    let resp;
    try {
      resp = await fetch(url, options);
    } catch (networkError) {
      const error = new Error('Network error while contacting the server');
      error.detail = { network: true, original: String(networkError) };
      throw error;
    }

    const contentType = resp.headers.get('content-type') || '';
    let rawText = '';
    try {
      rawText = await resp.text();
    } catch (bodyError) {
      const error = new Error('Failed to read response body');
      error.detail = { original: String(bodyError) };
      error.status = resp.status;
      throw error;
    }

    let data = null;
    if (contentType.includes('application/json') && rawText) {
      try {
        data = JSON.parse(rawText);
      } catch (parseError) {
        const error = new Error('Invalid JSON response received');
        error.detail = { raw: rawText };
        error.status = resp.status;
        throw error;
      }
    }

    if (!resp.ok) {
      const error = new Error(data?.message || 'Request failed');
      error.detail = data || (rawText ? { raw: rawText } : {});
      error.status = resp.status;
      throw error;
    }

    if (data !== null) {
      return data;
    }
    return rawText ? { raw: rawText } : {};
  }

  async function fetchContactDetails(email) {
    const trimmed = (email || '').trim();
    if (!trimmed) {
      return null;
    }
    const url = new URL('/box/collaborators/contact', window.location.origin);
    url.searchParams.set('email', trimmed);
    try {
      return await fetchJSON(url);
    } catch (error) {
      if (error.status === 404) {
        return null;
      }
      throw error;
    }
  }

function normalizeFolderId(raw) {
  const value = (raw || '').trim();
  if (!value) return '';
  const urlMatch = value.match(/(?:folder=|folders\/|folder\/)(\d{5,})/i);
  if (urlMatch) {
    return urlMatch[1];
  }
  const idMatch = value.match(/(\d{5,})/);
  return idMatch ? idMatch[1] : value;
}

async function suggestFolder() {
  if (!suggestFolderButton) return;
  setBusy(suggestFolderButton, true, 'Searching…');
  statusText.textContent = 'Searching for a client folder without metadata…';
  if (folderSuggestionNote) folderSuggestionNote.innerHTML = '';
  errorCard.classList.add('hidden');
  try {
    const data = await fetchJSON('/_public/box/folder/missing-metadata');
    const issues = Array.isArray(data.issues) ? data.issues : [];
    const folders = Array.isArray(data.folders)
      ? data.folders
      : (data.folder ? [data.folder] : []);
    resetUI();
    renderFolderSuggestions(folders, issues, data.message, { nextCursor: data.next_cursor });
  } catch (error) {
    showError(error);
  } finally {
    setBusy(suggestFolderButton, false);
  }
}

function renderFolderSuggestions(folders, issues, message, options = {}) {
  if (!folderSuggestionNote) return;

  const { append = false, nextCursor = null } = options;

  const cleaned = Array.isArray(folders)
    ? folders.filter((folder) => folder && (folder.id || folder.name))
    : [];

  const existingKeys = new Set(
    currentFolderSuggestions.map((folder) => (folder.id || folder.name || '').toString().trim())
  );

  const newEntries = [];
  cleaned.forEach((folder) => {
    const key = (folder.id || folder.name || '').toString().trim();
    if (!key || existingKeys.has(key)) {
      return;
    }
    existingKeys.add(key);
    newEntries.push(folder);
  });

  if (!append) {
    folderSuggestionNote.innerHTML = '';
    currentFolderSuggestions = [];
    currentFolderInfo = {};
    updateFolderSummary();
  }

  let intro = folderSuggestionNote.querySelector('.suggestion-intro');
  if (!intro) {
    intro = document.createElement('div');
    intro.className = 'suggestion-intro muted small';
    folderSuggestionNote.appendChild(intro);
  }
  intro.textContent = message || 'Select a folder below to load collaborators.';

  let list = folderSuggestionNote.querySelector('.suggestion-list');
  if (!list) {
    list = document.createElement('div');
    list.className = 'suggestion-list';
    folderSuggestionNote.appendChild(list);
  }

  const startIndex = append ? currentFolderSuggestions.length : 0;

  newEntries.forEach((folder, offset) => {
    const globalIndex = startIndex + offset;
    const checkboxId = `folder-suggestion-${globalIndex}`;
    const item = document.createElement('label');
    item.className = 'suggestion-item';
    item.setAttribute('for', checkboxId);

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.dataset.suggestionIndex = String(globalIndex);

    const info = document.createElement('div');
    const folderId = normalizeFolderId(folder.id || '');
    const displayName = folder.name || folderId || `Folder ${globalIndex + 1}`;
    const linkUrl = (folder.url || '').trim();
    const path = (folder.path || '').trim();

    const titleLine = document.createElement('div');
    const title = document.createElement('strong');
    title.textContent = displayName;
    titleLine.appendChild(title);
    if (linkUrl) {
      titleLine.appendChild(document.createTextNode(' · '));
      const anchor = document.createElement('a');
      anchor.href = linkUrl;
      anchor.target = '_blank';
      anchor.rel = 'noopener';
      anchor.textContent = 'Open';
      titleLine.appendChild(anchor);
    }
    info.appendChild(titleLine);

    if (path || folderId) {
      const detailLine = document.createElement('div');
      detailLine.className = 'muted small';
      detailLine.textContent = path || `ID: ${folderId}`;
      info.appendChild(detailLine);
    }

    item.appendChild(checkbox);
    item.appendChild(info);
    list.appendChild(item);

    checkbox.addEventListener('change', async (event) => {
      if (!event.target.checked) {
        item.classList.remove('highlight');
        return;
      }
      list.querySelectorAll('input[data-suggestion-index]').forEach((input) => {
        if (input !== event.target) {
          input.checked = false;
          if (input.parentElement) {
            input.parentElement.classList.remove('highlight');
          }
        }
      });
      item.classList.add('highlight');
      const indexValue = Number(event.target.dataset.suggestionIndex);
      if (!Number.isNaN(indexValue)) {
        await handleFolderSuggestionSelection(indexValue);
      }
    });
  });

  if (newEntries.length) {
    currentFolderSuggestions = append
      ? currentFolderSuggestions.concat(newEntries)
      : newEntries;
  } else if (!append) {
    currentFolderSuggestions = [];
  }

  let issuesWrapper = folderSuggestionNote.querySelector('.suggestion-issues-wrapper');
  if (!issuesWrapper) {
    issuesWrapper = document.createElement('div');
    issuesWrapper.className = 'suggestion-issues-wrapper hidden';
    folderSuggestionNote.appendChild(issuesWrapper);
  }
  if (!append) {
    issuesWrapper.innerHTML = '';
  }
  if (Array.isArray(issues) && issues.length) {
    const issueList = document.createElement('ul');
    issueList.className = 'suggestion-issues';
    issues.forEach((msg) => {
      const li = document.createElement('li');
      li.textContent = msg;
      issueList.appendChild(li);
    });
    issuesWrapper.appendChild(issueList);
  }
  if (issuesWrapper.innerHTML.trim()) {
    issuesWrapper.classList.remove('hidden');
  } else {
    issuesWrapper.classList.add('hidden');
  }

  if (!currentFolderSuggestions.length) {
    intro.textContent = message || 'No untagged folders found.';
    if (list) {
      list.innerHTML = '';
    }
  }

  updateSuggestionNavigation(nextCursor);

  if (statusText) {
    if (append) {
      if (newEntries.length) {
        statusText.textContent = 'Additional untagged folders loaded.';
      } else {
        statusText.textContent = message || 'No more untagged folders found.';
      }
    } else {
      statusText.textContent = currentFolderSuggestions.length
        ? 'Select a folder to continue.'
        : (message || 'No untagged folders found.');
    }
  }
}

  function updateSuggestionNavigation(nextCursor) {
    if (typeof nextCursor === 'number' && nextCursor >= 0) {
      currentSuggestionCursor = nextCursor;
    } else if (typeof nextCursor === 'string' && nextCursor.trim() !== '') {
      const parsed = Number(nextCursor);
      currentSuggestionCursor = Number.isNaN(parsed) ? nextCursor : parsed;
    } else {
      currentSuggestionCursor = null;
    }

    if (!loadMoreSuggestionsButton) {
      return;
    }

    if (currentSuggestionCursor !== null && currentSuggestionCursor !== '') {
      loadMoreSuggestionsButton.classList.remove('hidden');
      loadMoreSuggestionsButton.disabled = false;
      loadMoreSuggestionsButton.textContent = loadMoreSuggestionsButton.dataset.default || 'Show Next 5';
    } else {
      loadMoreSuggestionsButton.classList.add('hidden');
    }
  }

  async function loadNextSuggestions() {
    if (currentSuggestionCursor === null || currentSuggestionCursor === undefined || currentSuggestionCursor === '') {
      statusText.textContent = 'No additional untagged folders available.';
      return;
    }
    if (!loadMoreSuggestionsButton) {
      return;
    }
    setBusy(loadMoreSuggestionsButton, true, 'Loading…');
    try {
      const params = new URLSearchParams();
      params.set('cursor', String(currentSuggestionCursor));
      const data = await fetchJSON(`/_public/box/folder/missing-metadata?${params.toString()}`);
      const folders = Array.isArray(data.folders)
        ? data.folders
        : (data.folder ? [data.folder] : []);
      const issues = Array.isArray(data.issues) ? data.issues : [];
      renderFolderSuggestions(folders, issues, data.message, { append: true, nextCursor: data.next_cursor });
    } catch (error) {
      showError(error);
    } finally {
      setBusy(loadMoreSuggestionsButton, false);
    }
  }

  async function handleFolderSuggestionSelection(index) {
    const suggestion = currentFolderSuggestions[index];
    if (!suggestion) {
      return;
    }
    const folderId = normalizeFolderId(suggestion.id || '');
    if (!folderId) {
      statusText.textContent = 'Selected folder does not have a valid id.';
      return;
    }

    const name = suggestion.name || folderId;
    folderInput.value = folderId;
    rootFolderId = folderId;
    currentFolderId = folderId;
    selectedSubfolderId = null;
    selectedSubfolderName = null;
    statusText.textContent = `Loading collaborators for ${name}…`;

    const inputs = folderSuggestionNote
      ? Array.from(folderSuggestionNote.querySelectorAll('input[data-suggestion-index]'))
      : [];
    inputs.forEach((input) => {
      input.disabled = true;
    });
    try {
      await showCollaborators(null, folderId, null, null);
      if (!errorCard || errorCard.classList.contains('hidden')) {
        await loadSubfolders({ folderId, auto: true });
      }
    } finally {
      inputs.forEach((input) => {
        input.disabled = false;
      });
    }
  }

  async function loadSubfolders(options = {}) {
    if (options instanceof Event) {
      options = {};
    }
    const opts = typeof options === 'object' && options !== null ? options : {};
    const auto = Boolean(opts.auto);
    const providedId = typeof opts.folderId === 'string' ? opts.folderId : '';
    const rawFolderValue = providedId || folderInput.value.trim();
    const folderId = normalizeFolderId(rawFolderValue);
    if (!folderId) {
      if (!auto) {
        statusText.textContent = 'Validation error · folder id required';
      }
      return;
    }

    if (!providedId && folderId !== rawFolderValue) {
      folderInput.value = folderId;
    }

    const busyTarget = auto ? null : loadSubfoldersButton;
    if (busyTarget) {
      setBusy(busyTarget, true, 'Loading…');
    }
    errorCard.classList.add('hidden');

    try {
      const url = new URL('/box/folder/subfolders', window.location.origin);
      url.searchParams.set('folder_id', folderId);
      const data = await fetchJSON(url);
      currentFolderId = folderId;
      rootFolderId = folderId;
      renderSubfolders(data.subfolders || [], folderId);
      if (!auto) {
        statusText.textContent = (data.subfolders || []).length
          ? 'Select a subfolder then choose Show Collaborators.'
          : 'No subfolders found for this folder.';
      }
    } catch (error) {
      if (auto) {
        const detail = error && error.message ? error.message : 'Unknown error';
        statusText.textContent = `Subfolder load failed · ${detail}`;
        console.error('Automatic subfolder load failed:', error);
      } else {
        showError(error);
      }
    } finally {
      if (busyTarget) {
        setBusy(busyTarget, false);
      }
    }
  }

  function renderSubfolders(subfolders, folderId, activeSubfolderId) {
    subfolderWrapper.classList.remove('hidden');
    subfolderList.innerHTML = '';
    currentFolderId = folderId;

    const targetSubfolderId = activeSubfolderId || selectedSubfolderId || null;
    selectedSubfolderId = null;
    selectedSubfolderName = null;

    if (Array.isArray(subfolders) && subfolders.length) {
      subfolderActions.classList.remove('hidden');
      subfolders.forEach((child) => {
        const item = document.createElement('label');
        item.className = 'subfolder-item';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = child.id;
        checkbox.dataset.name = child.name;
        checkbox.addEventListener('change', () => {
          if (!checkbox.checked) {
            selectedSubfolderId = null;
            selectedSubfolderName = null;
            return;
          }
          subfolderList.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
            if (cb !== checkbox) cb.checked = false;
          });
          selectedSubfolderId = child.id;
          selectedSubfolderName = child.name;
          currentFolderId = folderId;
        });
        const text = document.createElement('span');
        text.innerHTML = `<strong>${child.name || 'Untitled'}</strong> <small class="muted">(#${child.id})</small>`;
        item.appendChild(checkbox);
        item.appendChild(text);
        subfolderList.appendChild(item);

        if (targetSubfolderId && targetSubfolderId === String(child.id)) {
          checkbox.checked = true;
          selectedSubfolderId = String(child.id);
          selectedSubfolderName = child.name || null;
          statusText.textContent = `Selected subfolder ${selectedSubfolderName || selectedSubfolderId}`;
        }
      });
      subfolderList.classList.remove('hidden');
      subfolderEmpty.classList.add('hidden');
    } else {
      subfolderList.classList.add('hidden');
      subfolderEmpty.classList.remove('hidden');
      subfolderActions.classList.add('hidden');
    }
  }

  async function showCollaborators(button, folderId, subfolderId, subfolderName) {
    const normalizedFolderId = normalizeFolderId(folderId);
    if (normalizedFolderId !== folderId) {
      folderId = normalizedFolderId;
      folderInput.value = folderId;
    }

    if (!folderId) {
      statusText.textContent = 'Validation error · folder id required';
      return;
    }

    if (!subfolderId) {
      rootFolderId = folderId;
    }

    setBusy(button, true, 'Loading…');
    errorCard.classList.add('hidden');

    try {
      const url = new URL('/box/folder/collaborators', window.location.origin);
      url.searchParams.set('folder_id', folderId);
      if (subfolderId) {
        url.searchParams.set('subfolder_id', subfolderId);
        if (subfolderName) {
          url.searchParams.set('subfolder', subfolderName);
        }
      }
      const data = await fetchJSON(url);
      currentFolderId = folderId;
      if (!rootFolderId) {
        rootFolderId = folderId;
      }
      renderCollaborators(data);
      rootFolderId = data.folder_id || rootFolderId || folderId;
      statusText.textContent = `Success · ${data.total} collaborators found`;
    } catch (error) {
      showError(error);
    } finally {
      setBusy(button, false);
    }
  }

  function renderCollaborators(data) {
    lastCollabResponse = data || null;
    lastContactData = null;
    contactCard.classList.add('hidden');
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    if (metadataActions) {
      metadataActions.classList.add('hidden');
      metadataStatus.textContent = '';
      metadataButton.disabled = false;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
    if (dealCard) dealCard.classList.add('hidden');
    currentDealList = [];
    currentSelectedDeal = null;

    const pivotDomain = '@pivotwealth.com.au';
    const collaborators = Array.isArray(data.collaborators) ? data.collaborators : [];
    const external = (data.external && Array.isArray(data.external))
      ? data.external
      : collaborators.filter(
          (collab) => collab.email && !collab.email.endsWith(pivotDomain)
        );
    collabTotal.textContent = collaborators.length;
    const externalCount = external.length;
    externalTotal.textContent = externalCount;

    let summaryText;
    if (data.inspected && data.inspected.id) {
      const inspectedName = data.inspected.name || 'Folder';
      summaryText = `Inspecting ${inspectedName} (id ${data.inspected.id})`;
    } else {
      summaryText = `Inspecting folder ${data.target_folder_id}`;
    }
    summaryTarget.textContent = `${summaryText} · ${externalCount} external collaborators highlighted`;
    if (data.root_folder) {
      currentFolderInfo = {
        id: data.root_folder.id || data.folder_id || '',
        name: data.root_folder.name || '',
        url: data.root_folder.url || '',
        path: data.root_folder.path || '',
      };
    } else {
      currentFolderInfo = {
        id: data.folder_id || '',
        name: data.folder?.name || data.inspected?.name || '',
        url: data.folder?.url || '',
      };
    }
    updateFolderSummary();

    collabTableBody.innerHTML = '';
    if (!external.length) {
      collabTableBody.innerHTML = '<tr><td colspan="5" class="muted">No external collaborators found.</td></tr>';
    } else {
      external.forEach((collab) => {
        const tr = document.createElement('tr');
        const email = collab.email || '—';
        tr.classList.add('external');
        tr.dataset.isExternal = '1';

        tr.innerHTML = `
          <td>${email}</td>
          <td>${collab.name || '—'}</td>
          <td>${collab.role || '—'}</td>
          <td>${collab.status || '—'}</td>
          <td><button type="button" class="secondary hubspot-btn" data-email="${email}">HubSpot Details</button></td>
        `;
        collabTableBody.appendChild(tr);
      });
    }

    if (externalCount) {
      externalList.innerHTML = '';
      external.forEach((collab) => {
        const li = document.createElement('li');
        li.textContent = `${collab.email} (${collab.name || 'no name'})`;
        externalList.appendChild(li);
      });
      externalCard.classList.remove('hidden');
      externalList.classList.remove('hidden');
      externalEmpty.classList.add('hidden');
    } else {
      externalCard.classList.add('hidden');
      externalList.classList.add('hidden');
      externalEmpty.classList.remove('hidden');
      externalEmpty.textContent = 'No external collaborators detected.';
    }

    contactCard.classList.add('hidden');
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    resultsWrapper.classList.remove('hidden');
    updateFolderSummary();
    updateDealButtonState();
  }

  function renderContactDetails(data) {
    if (!data || !data.contact) {
      lastContactData = null;
      contactDetails.textContent = 'No HubSpot details found.';
      contactCard.classList.remove('hidden');
      if (metadataActions) {
        metadataActions.classList.add('hidden');
        metadataStatus.textContent = 'Metadata creation requires contact and deal context.';
      }
      if (metadataPreviewButton) {
        metadataPreviewButton.disabled = true;
      }
      if (metadataPreview) {
        metadataPreview.classList.add('hidden');
      }
      if (metadataPreviewContent) {
        metadataPreviewContent.textContent = '';
      }
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    updateDealButtonState();
    return;
  }

    lastContactData = data;
    const contact = data.contact;
    const props = contact.properties || {};
    const deals = data.deals || [];
    const warnings = Array.isArray(data.warnings) ? data.warnings : [];

    let html = '<table><tbody>';
    html += `<tr><th>ID</th><td>${contact.id || '—'}</td></tr>`;
    html += `<tr><th>Name</th><td>${props.firstname || ''} ${props.lastname || ''}</td></tr>`;
    html += `<tr><th>Email</th><td>${props.email || '—'}</td></tr>`;
    html += `<tr><th>Phone</th><td>${props.phone || '—'}</td></tr>`;
    if (contact.url) {
      html += `<tr><th>HubSpot</th><td><a href="${contact.url}" target="_blank" rel="noopener">Open Contact</a></td></tr>`;
    }
    html += '</tbody></table>';

    contactDetails.innerHTML = html;
    contactCard.classList.remove('hidden');
    if (metadataActions) {
      metadataActions.classList.remove('hidden');
      metadataStatus.textContent = deals.length
        ? 'Tick a checkbox next to a deal before applying metadata.'
        : 'No associated deals found. You will be prompted for details before applying.';
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    renderWarnings(warnings);
    renderDealList(deals);
    updateDealButtonState();
  }

  async function createMetadata() {
    if (!metadataButton) {
      return;
    }

    const folderValue = rootFolderId
      || (lastCollabResponse && lastCollabResponse.inspected && lastCollabResponse.inspected.id)
      || currentFolderId
      || folderInput.value.trim();
    const folderId = normalizeFolderId(folderValue);
    if (!folderId) {
      metadataStatus.textContent = 'Folder id is unavailable. Load collaborators first.';
      return;
    }
    if (folderId !== folderValue) {
      folderInput.value = folderId;
    }

    let selectedDeal = currentSelectedDeal;
    let dealId = '';
    if (!selectedDeal) {
      const manual = window.prompt('Enter HubSpot deal id for metadata tagging');
      if (manual === null) {
        metadataStatus.textContent = 'Metadata creation cancelled.';
        return;
      }
      dealId = (manual || '').trim();
      if (!dealId) {
        metadataStatus.textContent = 'Deal id is required to apply metadata.';
        return;
      }
      if (metadataStatus) {
        metadataStatus.textContent = 'Using manually supplied deal id.';
      }
      const possibleDeals = Array.isArray(lastContactData?.deals) ? lastContactData.deals : [];
      selectedDeal = possibleDeals.find((deal) => {
        const props = deal.properties || {};
        return props.hs_deal_record_id === dealId || String(deal.id) === dealId;
      }) || null;
      if (selectedDeal) {
        currentSelectedDeal = selectedDeal;
      }
      if (dealMessage) {
        dealMessage.textContent = selectedDeal
          ? `Using ${selectedDeal.properties?.dealname || dealId}`
          : `Using manual deal id ${dealId}`;
      }
    } else {
      const dealProps = selectedDeal.properties || {};
      dealId = String(dealProps.hs_deal_record_id || selectedDeal.id || '').trim();
      if (!dealId) {
        metadataStatus.textContent = 'Selected deal is missing an id; please choose another deal.';
        return;
      }
    }

    const payload = {
      folder_id: folderId,
      deal_id: dealId,
      hs_deal_record_id: dealId,
    };

    if (lastContactData && lastContactData.contact) {
      const contact = lastContactData.contact;
      const props = contact.properties || {};
      if (contact.id) payload.hs_contact_id = contact.id;
      if (props.firstname) payload.hs_contact_firstname = props.firstname;
      if (props.lastname) payload.hs_contact_lastname = props.lastname;
      if (props.email) payload.hs_contact_email = props.email;
    }

    if (selectedDeal && selectedDeal.properties) {
      const props = selectedDeal.properties;
      if (props.deal_salutation) payload.deal_salutation = props.deal_salutation;
      if (props.household_type) payload.household_type = props.household_type;
      if (props.hs_spouse_id) payload.hs_spouse_id = props.hs_spouse_id;
      if (props.hs_spouse_firstname) payload.hs_spouse_firstname = props.hs_spouse_firstname;
      if (props.hs_spouse_lastname) payload.hs_spouse_lastname = props.hs_spouse_lastname;
      if (props.hs_spouse_email) payload.hs_spouse_email = props.hs_spouse_email;
    }

    generateMetadataPreview(payload, selectedDeal);
    const confirmed = window.confirm('Apply metadata using the previewed values?');
    if (!confirmed) {
      metadataStatus.textContent = 'Metadata creation cancelled.';
      statusText.textContent = 'Metadata apply cancelled.';
      return;
    }

    statusText.textContent = 'Applying metadata…';
    metadataStatus.textContent = 'Applying metadata…';
    setBusy(metadataButton, true, 'Working…');

    try {
      const data = await fetchJSON('/box/folder/tag/auto', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });
      metadataStatus.textContent = `Metadata applied. Fields updated: ${data.metadata_fields.length}`;
      statusText.textContent = `Metadata applied to folder ${data.folder_id}`;
    } catch (error) {
      metadataStatus.textContent = `Metadata creation failed: ${error.message}`;
      statusText.textContent = `Metadata error · ${error.message}`;
      errorCard.classList.remove('hidden');
      const detailText = error.detail && Object.keys(error.detail).length
        ? `<br/><code>${JSON.stringify(error.detail, null, 2)}</code>`
        : '';
      errorCard.innerHTML = `<strong>Error:</strong> ${error.message}${detailText}`;
      console.error(error);
    } finally {
      setBusy(metadataButton, false);
    }
  }

  function showError(error) {
    const detail = error.detail || {};
    errorCard.classList.remove('hidden');
    const prettyDetail = detail && Object.keys(detail).length ? JSON.stringify(detail, null, 2) : '';
    errorCard.innerHTML = `<strong>Error:</strong> ${error.message}${prettyDetail ? `<br/><code>${prettyDetail}</code>` : ''}`;
    statusText.textContent = `Error · ${error.message}`;
    resultsWrapper.classList.add('hidden');
    externalCard.classList.add('hidden');
    contactCard.classList.add('hidden');
    if (dealCard) dealCard.classList.add('hidden');
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
    currentFolderInfo = {};
    updateFolderSummary();
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    currentSuggestionCursor = null;
    updateSuggestionNavigation(null);
    updateDealButtonState();
    console.error(error);
  }

  if (loadSubfoldersButton) {
    loadSubfoldersButton.addEventListener('click', () => {
      loadSubfolders();
    });
  }

  if (loadMoreSuggestionsButton) {
    loadMoreSuggestionsButton.addEventListener('click', () => {
      loadNextSuggestions();
    });
  }

  if (suggestFolderButton) {
    suggestFolderButton.addEventListener('click', () => {
      suggestFolder();
    });
  }

  rootShowButton.addEventListener('click', () => {
    const folderId = folderInput.value.trim();
    showCollaborators(rootShowButton, folderId, selectedSubfolderId, selectedSubfolderName);
  });

  subfolderShowButton.addEventListener('click', () => {
    const folderId = currentFolderId || folderInput.value.trim();
    if (!selectedSubfolderId) {
      statusText.textContent = 'Select a subfolder before showing collaborators.';
      return;
    }
    showCollaborators(subfolderShowButton, folderId, selectedSubfolderId, selectedSubfolderName);
  });

  resetButton.addEventListener('click', () => {
    folderInput.value = '';
    resetUI();
    folderInput.focus();
  });

  subfolderList.addEventListener('click', (event) => {
    const checkbox = event.target.closest('input[type="checkbox"]');
    if (!checkbox) return;
    if (checkbox.checked) {
      statusText.textContent = `Selected subfolder ${checkbox.dataset.name || checkbox.value}`;
    }
  });

  collabTableBody.addEventListener('click', async (event) => {
    const button = event.target.closest('button[data-email]');
    if (!button) return;
    const email = button.dataset.email;
    if (!email || email === '—') {
      contactDetails.textContent = 'No email available for this collaborator.';
      contactCard.classList.remove('hidden');
      return;
    }

    setBusy(button, true, 'Loading…');
    try {
      const data = await fetchContactDetails(email);
      renderContactDetails(data);
      if (data && data.contact) {
        statusText.textContent = `Loaded HubSpot details for ${email}`;
      } else {
        statusText.textContent = `No HubSpot match for ${email}`;
      }
    } catch (error) {
      showError(error);
    } finally {
      setBusy(button, false);
    }
  });

  function handleEnterKey(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      rootShowButton.click();
    }
  }

  folderInput.addEventListener('keypress', handleEnterKey);

  if (metadataButton) {
    metadataButton.addEventListener('click', () => {
      createMetadata();
    });
  }

  if (metadataPreviewButton) {
    metadataPreviewButton.addEventListener('click', () => {
      if (!currentSelectedDeal) {
        metadataStatus.textContent = 'Select a deal before generating the metadata preview.';
        return;
      }
      generateMetadataPreview();
    });
  }

  if (metadataDealButton) {
    metadataDealButton.addEventListener('click', () => {
      updateDealBoxFolder();
    });
  }

  function renderWarnings(warnings, options = {}) {
    if (!metadataWarningList) {
      return;
    }
    const { append = false } = options;
    if (!append) {
      currentContactWarnings = new Map();
    }
    (Array.isArray(warnings) ? warnings : []).forEach((warning) => {
      if (!warning || !warning.message) {
        return;
      }
      const scope = warning.scope ? String(warning.scope) : '';
      const message = String(warning.message);
      const key = `${scope}|${message}`;
      if (!currentContactWarnings.has(key)) {
        currentContactWarnings.set(key, { scope, message });
      }
    });

    if (!currentContactWarnings.size) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
      return;
    }

    metadataWarningList.classList.remove('hidden');
    const items = Array.from(currentContactWarnings.values()).map(({ scope, message }) => {
      const scopeLabel = scope ? `<strong>${scope.replace(/_/g, ' ')}:</strong> ` : '';
      return `<li>${scopeLabel}${message}</li>`;
    }).join('');
    metadataWarningList.innerHTML = `<p><strong>Warnings</strong></p><ul>${items}</ul>`;
  }

  function buildMetadataPreview(payload, deal, contact) {
    const primaryName = [payload.hs_contact_firstname, payload.hs_contact_lastname]
      .filter(Boolean)
      .join(' ')
      .trim();
    const spouseName = [payload.hs_spouse_firstname, payload.hs_spouse_lastname]
      .filter(Boolean)
      .join(' ')
      .trim();

    const portalId = extractPortalIdFromUrl(contact?.url);
    const primaryLink = contact?.url || buildContactLink(portalId, payload.hs_contact_id);
    const spouseLink = buildContactLink(portalId, payload.hs_spouse_id);

    const associatedIdSet = new Set();
    const associatedContacts = [];
    const seenContactKeys = new Set();

    const pushAssociatedContact = ({ name, email, id, link }) => {
      const trimmedId = (id || '').trim();
      const key = `${trimmedId}|${(email || name || '').toLowerCase()}`;
      if (key && seenContactKeys.has(key)) {
        return;
      }
      if (key) {
        seenContactKeys.add(key);
      }
      if (trimmedId) {
        associatedIdSet.add(trimmedId);
      }
      associatedContacts.push(
        formatAssociatedContact({
          name: name || 'Contact',
          email: email || '',
          id: trimmedId,
          link: link,
        })
      );
    };

    if (primaryName || payload.hs_contact_id || payload.hs_contact_email) {
      pushAssociatedContact({
        name: primaryName || 'Primary Contact',
        email: payload.hs_contact_email || '',
        id: payload.hs_contact_id || '',
        link: primaryLink,
      });
    }
    if (spouseName || payload.hs_spouse_id || payload.hs_spouse_email) {
      pushAssociatedContact({
        name: spouseName || 'Spouse',
        email: payload.hs_spouse_email || '',
        id: payload.hs_spouse_id || '',
        link: spouseLink,
      });
    }

    const additionalContactsRaw = Array.isArray(deal?.associated_contacts)
      ? deal.associated_contacts.filter(Boolean)
      : [];

    const additionalContactSummaries = [];

    additionalContactsRaw.forEach((assoc, index) => {
      const assocProps = assoc || {};
      const assocId = (assocProps.id || '').trim();
      const assocEmail = (assocProps.email || '').trim();
      const nameParts = [];
      if (assocProps.firstname) nameParts.push(String(assocProps.firstname));
      if (assocProps.lastname) nameParts.push(String(assocProps.lastname));
      const assocName = assocProps.display_name
        || nameParts.join(' ').trim()
        || assocEmail
        || `Associated Contact ${index + 1}`;
      pushAssociatedContact({
        name: assocName,
        email: assocEmail,
        id: assocId,
        link: assocProps.url,
      });
      additionalContactSummaries.push({
        id: assocId,
        name: assocName,
        email: assocEmail,
        link: assocProps.url || buildContactLink(portalId, assocId),
      });
    });

    const associatedIds = Array.from(associatedIdSet);

    const metadataFields = {
      deal_salutation: payload.deal_salutation || '',
      household_type: payload.household_type || '',
      primary_contact_id: payload.hs_contact_id || '',
      primary_contact_link: primaryLink || '',
      hs_spouse_id: payload.hs_spouse_id || '',
      spouse_contact_link: spouseLink || '',
      associated_contact_ids: associatedIds.join(', ') || '',
      associated_contacts: associatedContacts.join('\n') || '',
    };

    const dealDetails = (() => {
      if (!deal) return undefined;
      const props = deal.properties || {};
      return {
        id: props.hs_deal_record_id || deal.id || '',
        name: props.dealname || '',
        stage: props.dealstage || '',
        close_date: formatDate(extractDealTimestamp(deal)) || '',
      };
    })();

    return {
      folder_id: payload.folder_id,
      deal_id: payload.deal_id,
      deal: dealDetails,
      metadata_fields: metadataFields,
      contacts: {
        primary: {
          id: payload.hs_contact_id || '',
          name: primaryName || '',
          email: payload.hs_contact_email || '',
          link: primaryLink || '',
        },
        spouse: {
          id: payload.hs_spouse_id || '',
          name: spouseName || '',
          email: payload.hs_spouse_email || '',
          link: spouseLink || '',
          firstname: payload.hs_spouse_firstname || '',
          lastname: payload.hs_spouse_lastname || '',
        },
        additional: additionalContactSummaries,
      },
    };
  }

  function extractPortalIdFromUrl(url) {
    if (!url) return '';
    const match = String(url).match(/contacts\/(\d+)\/record/);
    return match ? match[1] : '';
  }

  function buildContactLink(portalId, contactId) {
    if (!portalId || !contactId) return undefined;
    return `https://app.hubspot.com/contacts/${portalId}/record/0-1/${contactId}`;
  }

  function formatAssociatedContact({ name, email, id, link }) {
    const parts = [];
    if (email) parts.push(email);
    if (id) parts.push(`ID: ${id}`);
    if (link) parts.push(`Link: ${link}`);
    if (!parts.length) return name || 'Contact';
    return `${name || 'Contact'} (${parts.join(' | ')})`;
  }

  function parseTimestamp(value) {
    if (!value && value !== 0) return 0;
    if (typeof value === 'number') return value;
    const str = String(value).trim();
    if (!str) return 0;
    if (/^\d+$/.test(str)) {
      const num = Number(str);
      if (Number.isNaN(num)) return 0;
      return num > 1e12 ? num : num * 1000;
    }
    const parsed = Date.parse(str);
    return Number.isNaN(parsed) ? 0 : parsed;
  }

  function extractDealTimestamp(deal) {
    const props = (deal && deal.properties) || {};
    const candidates = [
      props.agreement_start_date,
      props.closedate,
      props.hs_closed_won_date,
      deal?.updatedAt,
      deal?.createdAt,
    ];
    for (const candidate of candidates) {
      const ts = parseTimestamp(candidate);
      if (ts) return ts;
    }
    return 0;
  }

  function formatDate(ts) {
    if (!ts) return 'n/a';
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return 'n/a';
    return d.toISOString().slice(0, 10);
  }

  function similarityScore(a, b) {
    const src = (a || '').toLowerCase();
    const tgt = (b || '').toLowerCase();
    if (!src || !tgt) return 0;
    if (src === tgt) return 1;

    const bigrams = (text) => {
      const map = new Map();
      const normalized = text.replace(/[^a-z0-9]+/g, '');
      for (let i = 0; i < normalized.length - 1; i += 1) {
        const bg = normalized.slice(i, i + 2);
        map.set(bg, (map.get(bg) || 0) + 1);
      }
      return map;
    };

    const source = bigrams(src);
    const target = bigrams(tgt);
    if (!source.size || !target.size) return 0;

    let intersection = 0;
    let totalA = 0;
    let totalB = 0;
    source.forEach((count, key) => {
      totalA += count;
      if (target.has(key)) {
        intersection += Math.min(count, target.get(key));
      }
    });
    target.forEach((count) => {
      totalB += count;
    });

    const total = totalA + totalB;
    return total ? (2 * intersection) / total : 0;
  }

function renderDealList(deals) {
  if (!dealList || !dealCard) return;

  const sorted = Array.isArray(deals)
    ? [...deals].sort((a, b) => extractDealTimestamp(b) - extractDealTimestamp(a))
    : [];
  currentDealList = sorted;
  currentSelectedDeal = null;
  dealList.innerHTML = '';

  if (!sorted.length) {
    dealCard.classList.add('hidden');
    if (dealMessage) {
      dealMessage.textContent = 'No associated deals found.';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    currentSelectedDeal = null;
    updateDealButtonState();
    return;
  }

  sorted.forEach((deal, index) => {
    const props = deal.properties || {};
    const displayId = props.hs_deal_record_id || deal.id || `deal-${index}`;
    const name = props.dealname || `Deal ${displayId}`;
    const stage = props.dealstage || 'Unknown stage';
    const agreementDate = formatDate(
      parseTimestamp(props.agreement_start_date) || extractDealTimestamp(deal)
    );
    const amount = props.amount ? `$${props.amount}` : '—';
    const contactsStatus = deal.associated_contacts_status || 'unknown';

    const checkboxId = `deal-choice-${index}`;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.name = 'deal-choice';
    checkbox.value = String(index);
    checkbox.dataset.dealIndex = String(index);
    checkbox.id = checkboxId;
    checkbox.addEventListener('change', (event) => {
      handleDealCheckboxChange(event, index);
    });

    const item = document.createElement('div');
    item.className = 'deal-item';
    item.appendChild(checkbox);

    const label = document.createElement('label');
    label.setAttribute('for', checkboxId);
    const details = [
      `Stage: ${stage}`,
      `Agreement: ${agreementDate}`,
      `Amount: ${amount}`,
    ];
    let infoHtml = `<strong>${name}</strong><br/><span class="muted small">${details.join(' · ')}`;
    if (deal.url) {
      infoHtml += ` · <a href="${deal.url}" target="_blank" rel="noopener">Open</a>`;
    }
    infoHtml += '</span>';
    label.innerHTML = infoHtml;

    if (contactsStatus !== 'complete' && contactsStatus !== 'unknown') {
      const badge = document.createElement('span');
      badge.className = 'deal-badge';
      badge.textContent = 'Contacts incomplete';
      label.appendChild(badge);
    }

    item.appendChild(label);
    dealList.appendChild(item);
  });

  dealCard.classList.remove('hidden');
  if (dealMessage) {
    dealMessage.textContent = 'Tick the checkbox next to a deal to populate the metadata preview.';
  }
  if (metadataPreviewButton) {
    metadataPreviewButton.disabled = true;
  }
  if (metadataButton) {
    metadataButton.disabled = true;
  }
  updateDealButtonState();
}

function handleDealCheckboxChange(event, index) {
  const checkbox = event.target;
  if (!checkbox) return;

  const inputs = dealList
    ? Array.from(dealList.querySelectorAll('input[data-deal-index]'))
    : [];

  if (checkbox.checked) {
    inputs.forEach((input) => {
      const match = Number(input.dataset.dealIndex) === index;
      input.checked = match;
      if (input.parentElement) {
        input.parentElement.classList.toggle('highlight', match);
      }
    });
    setSelectedDeal(index, { updateInputs: false });
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = false;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    updateDealButtonState();
    return;
  }

  const anyChecked = inputs.some((input) => input.checked);
  if (!anyChecked) {
    setSelectedDeal(null);
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
  }
  updateDealButtonState();
}

function setSelectedDeal(index, options = {}) {
  const renderPreview = options.renderPreview === true;
  const updateInputs = options.updateInputs !== false;

  const inputs = dealList
    ? Array.from(dealList.querySelectorAll('input[data-deal-index]'))
    : [];

  if (
    index === null
    || index === undefined
    || !Array.isArray(currentDealList)
    || !currentDealList[index]
  ) {
    currentSelectedDeal = null;
    if (updateInputs) {
      inputs.forEach((input) => {
        input.checked = false;
        if (input.parentElement) {
          input.parentElement.classList.remove('highlight');
        }
      });
    }
    if (dealMessage) {
      dealMessage.textContent = inputs.length
        ? 'Tick the checkbox next to a deal to load metadata values.'
        : 'No associated deals found.';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreview) metadataPreview.classList.add('hidden');
    if (metadataPreviewContent) metadataPreviewContent.textContent = '';
    updateDealButtonState();
    return;
  }

  currentSelectedDeal = currentDealList[index];

  if (metadataPreview) metadataPreview.classList.add('hidden');
  if (metadataPreviewContent) metadataPreviewContent.textContent = '';

  if (updateInputs) {
    inputs.forEach((input) => {
      const isMatch = Number(input.dataset.dealIndex) === index;
      input.checked = isMatch;
      if (input.parentElement) {
        input.parentElement.classList.toggle('highlight', isMatch);
      }
    });
  }

  if (shouldAutoLoadSubfolders) {
    loadSubfolders({ folderId: presetFolderId, auto: true });
  }

  const props = currentSelectedDeal.properties || {};
  const displayId = props.hs_deal_record_id || currentSelectedDeal.id || '';
  const name = props.dealname || `Deal ${displayId || currentSelectedDeal.id}`;
  const stage = props.dealstage || 'Unknown stage';
  const agreementTs =
    parseTimestamp(props.agreement_start_date) || extractDealTimestamp(currentSelectedDeal);
  const agreementDisplay = formatDate(agreementTs);
  if (dealMessage) {
    dealMessage.textContent = `Using ${name} · Stage: ${stage} · Agreement: ${agreementDisplay}`;
  }
  if (metadataStatus) {
    metadataStatus.textContent = `Deal selected: ${name}. Click Preview Metadata to review before applying.`;
  }
  if (renderPreview) {
    generateMetadataPreview();
  }
  updateDealButtonState();
}

  function updateFolderSummary() {
    if (!folderSummary) {
      return;
    }
    const name = currentFolderInfo?.name || '';
    const url = currentFolderInfo?.url || '';
    if (!name) {
      folderSummary.textContent = '';
      folderSummary.innerHTML = '';
      folderSummary.title = '';
      return;
    }
    folderSummary.title = name;
    if (url) {
      folderSummary.innerHTML = `Folder: <a href="${url}" target="_blank" rel="noopener">${name}</a>`;
    } else {
      folderSummary.textContent = `Folder: ${name}`;
    }
  }

  function generateMetadataPreview(existingPayload, selectedDealOverride) {
    const payload = existingPayload || buildPayloadFromSelectedDeal(selectedDealOverride);
    if (!payload) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Metadata preview unavailable. Select a deal and ensure a folder id is set.';
      }
      return;
    }
    const previewData = buildMetadataPreview(payload, selectedDealOverride || currentSelectedDeal, lastContactData?.contact);
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = JSON.stringify(previewData, null, 2);
    }
    if (metadataPreview) {
      metadataPreview.classList.remove('hidden');
    }
  if (metadataStatus) {
    metadataStatus.textContent = 'Metadata preview generated. Review before applying.';
  }
  if (statusText) {
    statusText.textContent = 'Metadata preview generated.';
  }
  if (metadataButton) {
    metadataButton.disabled = false;
  }
  }

  function buildPayloadFromSelectedDeal(selectedDealOverride) {
    const folderValue = rootFolderId
      || (lastCollabResponse && lastCollabResponse.folder_id)
      || (lastCollabResponse && lastCollabResponse.inspected && lastCollabResponse.inspected.id)
      || currentFolderId
      || folderInput.value.trim();
    const folderId = normalizeFolderId(folderValue);
    if (!folderId) {
      return null;
    }

    const deal = selectedDealOverride || currentSelectedDeal;
    const dealProps = (deal && deal.properties) || {};
    const dealId = String(dealProps.hs_deal_record_id || deal?.id || '').trim();
    if (!dealId) {
      return null;
    }

    const payload = {
      folder_id: folderId,
      deal_id: dealId,
      hs_deal_record_id: dealId,
    };

    if (lastContactData && lastContactData.contact) {
      const contact = lastContactData.contact;
      const props = contact.properties || {};
      if (contact.id) payload.hs_contact_id = contact.id;
      if (props.firstname) payload.hs_contact_firstname = props.firstname;
      if (props.lastname) payload.hs_contact_lastname = props.lastname;
      if (props.email) payload.hs_contact_email = props.email;
    }

    if (dealProps) {
      if (dealProps.deal_salutation) payload.deal_salutation = dealProps.deal_salutation;
      if (dealProps.household_type) payload.household_type = dealProps.household_type;
      if (dealProps.hs_spouse_id) payload.hs_spouse_id = dealProps.hs_spouse_id;
      if (dealProps.hs_spouse_firstname) payload.hs_spouse_firstname = dealProps.hs_spouse_firstname;
      if (dealProps.hs_spouse_lastname) payload.hs_spouse_lastname = dealProps.hs_spouse_lastname;
      if (dealProps.hs_spouse_email) payload.hs_spouse_email = dealProps.hs_spouse_email;
    }

    return payload;
  }

  function resolveDealUpdateInputs(selectedDealOverride) {
    if (!metadataDealButton || !dealPropertyName) {
      return null;
    }
    const payload = buildPayloadFromSelectedDeal(selectedDealOverride);
    if (!payload) {
      return null;
    }
    const folderId = normalizeFolderId(payload.folder_id);
    const dealId = String(payload.deal_id || payload.hs_deal_record_id || '').trim();
    if (!folderId || !dealId) {
      return null;
    }
    return {
      folderId,
      dealId,
      payload,
      deal: selectedDealOverride || currentSelectedDeal,
    };
  }

  function canUpdateDealBoxUrl() {
    return Boolean(resolveDealUpdateInputs());
  }

  function updateDealButtonState() {
    if (!metadataDealButton) {
      return;
    }
    if (!dealPropertyName) {
      metadataDealButton.disabled = true;
      metadataDealButton.title = 'Configure HUBSPOT_BOX_FOLDER_DEAL_PROPERTY to enable deal updates.';
      return;
    }
    metadataDealButton.disabled = !canUpdateDealBoxUrl();
    if (!metadataDealButton.disabled) {
      metadataDealButton.title = '';
    }
  }

  async function updateDealBoxFolder() {
    if (!metadataDealButton) {
      return;
    }
    if (!dealPropertyName) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Configure HUBSPOT_BOX_FOLDER_DEAL_PROPERTY to enable deal updates.';
      }
      return;
    }

    const resolved = resolveDealUpdateInputs();
    if (!resolved) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Select a deal and ensure the folder id is loaded before updating the deal property.';
      }
      updateDealButtonState();
      return;
    }

    const { folderId, dealId, deal } = resolved;
    const properties = (deal && deal.properties) || {};
    const dealName = properties.dealname || `Deal ${dealId}`;

    if (metadataStatus) {
      metadataStatus.textContent = `Updating HubSpot deal ${dealName} with Box folder URL…`;
    }
    if (statusText) {
      statusText.textContent = 'Updating HubSpot deal with Box folder URL…';
    }
    setBusy(metadataDealButton, true, 'Updating…');

    try {
      const payload = {
        folder_id: folderId,
        deal_id: dealId,
        hs_deal_record_id: dealId,
      };
      const data = await fetchJSON('/box/folder/deal-box-url', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });
      if (metadataStatus) {
        const propertyLabel = dealPropertyName || 'box folder URL';
        metadataStatus.textContent = `HubSpot deal ${data.deal_id} updated (${propertyLabel}).`;
      }
      if (statusText) {
        statusText.textContent = `Success · Deal ${data.deal_id} updated with ${data.box_folder_url}`;
      }
    } catch (error) {
      if (metadataStatus) {
        metadataStatus.textContent = `Deal property update failed: ${error.message}`;
      }
      if (statusText) {
        statusText.textContent = `Deal update failed · ${error.message}`;
      }
      console.error('Deal box URL update failed:', error);
    } finally {
      setBusy(metadataDealButton, false);
      updateDealButtonState();
    }
  }

  resetUI();
</script>
{% endblock %}

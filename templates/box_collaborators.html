{% extends "layout.html" %}
{% set title = "Box Collaborator Lookup" %}

{% block content %}
<div class="topbar">
  <div style="display:flex;align-items:center;gap:16px;">
    <a href="/" style="color:#d0d7e2;text-decoration:none;font-size:0.9em;">← Home</a>
    <h2>Box Collaborator Lookup</h2>
  </div>
  <div class="datebox">
    <span class="muted small">Monitor live request progress below.</span>
  </div>
</div>

<div class="status-banner" id="status-banner">
  <span class="status-label">Status</span>
  <span id="status-text">Awaiting folder id</span>
</div>

<div class="card lookup-card">
  <p class="muted small">
    Enter a Box <code>folder_id</code>, optionally inspect subfolders, and review collaborator access.
    Collaborators load automatically with external addresses highlighted for quick review.
  </p>
  <form id="collab-form" class="collab-form">
    <label class="field">
      <span>Folder ID</span>
      <input type="text" id="folder-id" autocomplete="off" required />
    </label>
    <div class="actions root-actions">
      <button type="button" class="secondary" id="suggest-folder">Find Untagged Folder</button>
      <button type="button" class="primary" id="root-show" data-default="Show Collaborators">Show Collaborators</button>
      <button type="button" class="secondary" id="reset-btn">Cancel</button>
    </div>
    <div class="muted small suggestion-note" id="folder-suggestion-note"></div>
    <div class="suggestion-actions" id="folder-suggestion-actions">
      <button type="button" class="secondary" id="load-subfolders" data-default="Display Subfolders">Display Subfolders</button>
      <button type="button" class="secondary hidden" id="load-more-suggestions" data-default="Show Next 5">Show Next 5</button>
    </div>
    <div id="subfolder-wrapper" class="subfolder-wrapper hidden">
      <h3>Subfolders</h3>
      <p class="muted small" id="subfolder-empty">No subfolders loaded.</p>
      <div id="subfolder-list" class="subfolder-list hidden"></div>
      <div id="subfolder-actions" class="subfolder-actions hidden">
        <button type="button" class="primary" id="subfolder-show" data-default="Show Collaborators">Show Collaborators</button>
      </div>
    </div>
  </form>
</div>

<div id="results-wrapper" class="card hidden">
  <h3>Collaborators</h3>
  <p class="muted small" id="summary-target"></p>
  <p><strong>Total collaborators:</strong> <span id="collab-total">0</span></p>
  <p><strong>External collaborators:</strong> <span id="external-total">0</span></p>

  <div class="table-wrapper">
    <table>
      <thead>
        <tr>
          <th>Email</th>
          <th>Name</th>
          <th>Role</th>
          <th>Status</th>
          <th>HubSpot</th>
        </tr>
      </thead>
      <tbody id="collab-table-body">
        <tr><td colspan="5" class="muted">No results yet.</td></tr>
      </tbody>
    </table>
  </div>
</div>

<div id="contact-card" class="card hidden">
  <h3>HubSpot Contact Details</h3>
  <div id="contact-details" class="contact-details muted small">
    Select a collaborator to load HubSpot details.
  </div>
  <div id="deal-card" class="contact-deals hidden">
    <div class="deal-header">
      <div>
        <h4>Associated Deals</h4>
        <p class="muted small" id="deal-message">Tick the checkbox next to a deal to load metadata values.</p>
      </div>
      <div class="muted small" id="folder-summary"></div>
    </div>
    <div id="deal-list" class="deal-list"></div>
  </div>
  <div id="metadata-actions" class="contact-actions hidden">
    <button type="button" class="secondary" id="metadata-preview-btn" data-default="Preview Metadata">
      Preview Metadata
    </button>
    <button
      type="button"
      class="secondary"
      id="deal-box-url-btn"
      data-default="Update Deal Box URL"
      data-deal-property="{{ hubspot_deal_property or '' }}"
    >
      Update Deal Box URL
    </button>
    <button type="button" class="primary" id="metadata-create-btn" data-default="Create Box Metadata">
      Create Box Metadata
    </button>
    <p id="metadata-status" class="muted small"></p>
    <div id="metadata-warning-list" class="warning-list hidden"></div>
    <div id="metadata-preview" class="metadata-preview hidden">
      <h4 class="muted small">Metadata preview</h4>
      <pre id="metadata-preview-content"></pre>
    </div>
  </div>
</div>

<div id="error-card" class="card error-card hidden"></div>

<div id="metadata-summary-card" class="card summary-card hidden">
  <h3>Metadata Summary</h3>
  <div class="summary-overview">
    <p><strong>Box folder:</strong> <span id="summary-folder">—</span></p>
    <p><strong>Primary contact:</strong> <span id="summary-primary">—</span></p>
    <p><strong>Spouse:</strong> <span id="summary-spouse">—</span></p>
  </div>
  <div class="summary-metadata">
    <table class="summary-metadata-table">
      <thead>
        <tr>
          <th>Field</th>
          <th>Value</th>
        </tr>
      </thead>
      <tbody id="summary-metadata-body">
        <tr><td colspan="2">No metadata fields populated.</td></tr>
      </tbody>
    </table>
  </div>
</div>

{% endblock %}

{% block head %}
<style>
  .lookup-card {
    margin-bottom: 20px;
  }

  .status-banner {
    position: sticky;
    top: 0;
    z-index: 60;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 20px;
    margin-bottom: 20px;
    border-radius: 14px;
    border: 1px solid rgba(248, 250, 252, 0.08);
    background: linear-gradient(90deg, rgba(79, 70, 229, 0.95), rgba(16, 185, 129, 0.9));
    box-shadow: 0 18px 36px rgba(15, 23, 42, 0.28);
    color: #f8fafc;
  }

  .status-label {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.2);
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-weight: 700;
  }

  #status-text {
    font-size: 1.05rem;
    font-weight: 600;
    letter-spacing: 0.01em;
    color: #f8fafc;
  }

  .summary-card {
    margin-top: 20px;
    display: grid;
    gap: 16px;
  }

  .summary-card h3 {
    margin: 0;
    font-size: 1.2rem;
    color: #1f2937;
  }

  .summary-overview p {
    margin: 0;
    font-size: 0.95rem;
    color: #1f2937;
  }

  .summary-overview p + p {
    margin-top: 8px;
  }

  .summary-overview > p > span {
    display: inline-block;
    margin-left: 8px;
  }

  .summary-overview a {
    color: #2563eb;
  }

  .summary-metadata-table {
    width: 100%;
    border-collapse: collapse;
    box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08);
    border-radius: 12px;
    overflow: hidden;
  }

  .summary-metadata-table th,
  .summary-metadata-table td {
    padding: 12px 14px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.35);
    vertical-align: top;
    font-size: 0.9rem;
  }

  .summary-metadata-table th {
    background: rgba(241, 245, 249, 0.8);
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    color: #475569;
    width: 32%;
  }

  .summary-metadata-table td {
    color: #1f2937;
  }

  .summary-metadata-table td pre {
    margin: 0;
    font-size: 0.82rem;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .collab-form {
    display: grid;
    gap: 12px;
    max-width: 420px;
  }

  .field {
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-weight: 600;
  }

  .field span {
    font-size: 0.85em;
    color: #5a6578;
    font-weight: 500;
  }

  .actions,
  .subfolder-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .subfolder-wrapper {
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 12px;
    padding: 14px;
    background: rgba(15, 23, 42, 0.02);
    display: grid;
    gap: 10px;
  }

  .subfolder-list {
    display: grid;
    gap: 6px;
  }

  .subfolder-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.015);
  }

  .subfolder-item span {
    font-size: 0.85em;
    color: #52606d;
  }

  .suggestion-note {
    min-height: 1.2em;
  }

  .suggestion-list {
    display: grid;
    gap: 6px;
    margin-top: 8px;
  }

  .suggestion-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 8px 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.015);
  }

  .suggestion-item input[type="checkbox"] {
    margin-top: 3px;
  }

  .suggestion-item.highlight {
    border-color: rgba(16, 185, 129, 0.65);
    background: rgba(16, 185, 129, 0.08);
  }

  .suggestion-issues {
    margin: 6px 0 0 0;
    padding-left: 18px;
    font-size: 0.8em;
    line-height: 1.3;
  }

  .suggestion-issues-wrapper {
    margin-top: 8px;
    font-size: 0.8em;
  }

  .suggestion-issues-wrapper.hidden {
    display: none;
  }

  .suggestion-actions {
    margin-top: 8px;
  }

  .suggestion-actions button {
    margin-top: 4px;
  }

  .table-wrapper {
    overflow-x: auto;
  }

  table {
    width: 100%;
    border-collapse: collapse;
  }

  th,
  td {
    text-align: left;
    padding: 8px 10px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.35);
    font-size: 0.9em;
  }

  tr.external td {
    background: rgba(239, 68, 68, 0.12);
    color: #7f1d1d;
    font-weight: 600;
  }

  tr.external.selected td {
    background: rgba(239, 68, 68, 0.2);
    box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.4);
  }


  .deal-list {
    display: grid;
    gap: 6px;
    margin-top: 10px;
  }

  .deal-header {
    display: flex;
    justify-content: space-between;
    gap: 12px;
  }

  .deal-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    padding: 10px 12px;
    background: rgba(15, 23, 42, 0.015);
  }

  .deal-item input[type="checkbox"] {
    margin-top: 4px;
    flex-shrink: 0;
  }

  .deal-item label {
    flex: 1;
    cursor: pointer;
  }

  .deal-item.highlight {
    border-color: rgba(79, 70, 229, 0.55);
    background: rgba(79, 70, 229, 0.08);
  }

  .deal-item .deal-badge {
    display: inline-block;
    margin-top: 6px;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 0.72em;
    font-weight: 600;
    background: rgba(249, 115, 22, 0.18);
    color: #9a3412;
  }

  .pivot-toggle {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85em;
    color: #52606d;
    margin-bottom: 12px;
  }

  .contact-details {
    display: grid;
    gap: 10px;
  }

  .contact-deals {
    display: grid;
    gap: 6px;
    margin-top: 10px;
  }

  .contact-details table {
    width: 100%;
    border-collapse: collapse;
  }

  .contact-details th,
  .contact-details td {
    text-align: left;
    padding: 6px 8px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.35);
  }

  .contact-actions {
    margin-top: 12px;
    display: grid;
    gap: 6px;
  }

  .contact-actions button {
    width: fit-content;
  }

  .warning-list {
    margin-top: 4px;
    padding: 8px 10px;
    border-left: 3px solid #f97316;
    background: rgba(249, 115, 22, 0.12);
    color: #92400e;
    font-size: 0.8em;
    display: grid;
    gap: 6px;
  }

  .warning-list.hidden {
    display: none;
  }

  .warning-list ul {
    margin: 0;
    padding-left: 18px;
  }

  .warning-list li {
    margin: 0;
  }

  .metadata-preview {
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 10px;
    padding: 10px;
    background: rgba(15, 23, 42, 0.02);
    max-width: 420px;
  }

  .metadata-preview pre {
    margin: 6px 0 0 0;
    font-size: 0.82em;
    max-height: 220px;
    overflow: auto;
  }

  .hubspot-btn {
    font-size: 0.8em;
    padding: 4px 10px;
  }

  .error-card {
    border: 1px solid rgba(239, 68, 68, 0.35);
    color: #991b1b;
    background: rgba(239, 68, 68, 0.1);
    margin-top: 16px;
  }

</style>
{% endblock %}

{% block scripts %}
<script>
  const folderInput = document.getElementById('folder-id');
  const loadSubfoldersButton = document.getElementById('load-subfolders');
  const rootShowButton = document.getElementById('root-show');
  const resetButton = document.getElementById('reset-btn');
  const subfolderWrapper = document.getElementById('subfolder-wrapper');
  const subfolderList = document.getElementById('subfolder-list');
  const subfolderEmpty = document.getElementById('subfolder-empty');
  const subfolderActions = document.getElementById('subfolder-actions');
  const subfolderShowButton = document.getElementById('subfolder-show');
  const folderSuggestionNote = document.getElementById('folder-suggestion-note');
  const suggestionActions = document.getElementById('folder-suggestion-actions');
  const loadMoreSuggestionsButton = document.getElementById('load-more-suggestions');

  const statusText = document.getElementById('status-text');
  const resultsWrapper = document.getElementById('results-wrapper');
  const collabTotal = document.getElementById('collab-total');
  const externalTotal = document.getElementById('external-total');
  const summaryTarget = document.getElementById('summary-target');
  const collabTableBody = document.getElementById('collab-table-body');
  const suggestFolderButton = document.getElementById('suggest-folder');
  const dealCard = document.getElementById('deal-card');
  const dealList = document.getElementById('deal-list');
  const dealMessage = document.getElementById('deal-message');
  const folderSummary = document.getElementById('folder-summary');
  const errorCard = document.getElementById('error-card');
  const contactCard = document.getElementById('contact-card');
  const contactDetails = document.getElementById('contact-details');
  const metadataActions = document.getElementById('metadata-actions');
  const metadataPreviewButton = document.getElementById('metadata-preview-btn');
  const metadataDealButton = document.getElementById('deal-box-url-btn');
  const dealPropertyName = metadataDealButton ? (metadataDealButton.dataset.dealProperty || '').trim() : '';
  const metadataButton = document.getElementById('metadata-create-btn');
  const metadataStatus = document.getElementById('metadata-status');
  const metadataWarningList = document.getElementById('metadata-warning-list');
  const metadataPreview = document.getElementById('metadata-preview');
  const metadataPreviewContent = document.getElementById('metadata-preview-content');
  const summaryCard = document.getElementById('metadata-summary-card');
  const summaryFolder = document.getElementById('summary-folder');
  const summaryPrimary = document.getElementById('summary-primary');
  const summarySpouse = document.getElementById('summary-spouse');
  const summaryMetadataBody = document.getElementById('summary-metadata-body');
  const searchParams = new URLSearchParams(window.location.search);
  const presetFolderId = (searchParams.get('folder_id') || '').trim();
  const shouldAutoLoadSubfolders = Boolean(presetFolderId);
  if (presetFolderId && folderInput) {
    folderInput.value = presetFolderId;
    folderInput.focus();
  }

  let selectedSubfolderId = null;
  let selectedSubfolderName = null;
  let currentFolderId = '';
  let lastCollabResponse = null;
  let lastContactData = null;
  let rootFolderId = '';
  let currentDealList = [];
  let currentSelectedDeal = null;
  let currentFolderSuggestions = [];
  let currentSuggestionCursor = null;
  let currentContactWarnings = new Map();
  let currentFolderInfo = {};
  let collaboratorRegistry = new Map();
  let currentCollaboratorScanToken = 0;
  const pivotDomain = '@pivotwealth.com.au';
  let currentHighlightedEmail = null;

  function setBusy(button, busy, label) {
    if (!button) return;
    if (busy) {
      button.dataset.default = button.dataset.default || button.textContent;
      button.textContent = label;
      button.disabled = true;
    } else {
      button.textContent = button.dataset.default || 'Submit';
      button.disabled = false;
    }
  }

  function resetUI() {
    resultsWrapper.classList.add('hidden');
    errorCard.classList.add('hidden');
    contactCard.classList.add('hidden');
    if (metadataActions) {
      metadataActions.classList.add('hidden');
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    clearSummaryCard();
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    collabTableBody.innerHTML = '<tr><td colspan="5" class="muted">No results yet.</td></tr>';
    collaboratorRegistry = new Map();
    currentCollaboratorScanToken += 1;
    if (folderSuggestionNote) folderSuggestionNote.innerHTML = '';
    if (suggestionActions) suggestionActions.classList.remove('hidden');
    if (loadSubfoldersButton) {
      loadSubfoldersButton.disabled = false;
      const defaultLabel = loadSubfoldersButton.dataset.default || 'Display Subfolders';
      loadSubfoldersButton.textContent = defaultLabel;
    }
    if (loadMoreSuggestionsButton) {
      loadMoreSuggestionsButton.classList.add('hidden');
      loadMoreSuggestionsButton.disabled = false;
      loadMoreSuggestionsButton.textContent = loadMoreSuggestionsButton.dataset.default || 'Show Next 5';
    }
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
    if (dealCard) dealCard.classList.add('hidden');
    collabTotal.textContent = '0';
    externalTotal.textContent = '0';
    statusText.textContent = 'Awaiting folder id';
    summaryTarget.textContent = '';
    subfolderList.innerHTML = '';
    subfolderList.classList.add('hidden');
    subfolderEmpty.classList.remove('hidden');
    subfolderWrapper.classList.add('hidden');
    subfolderActions.classList.add('hidden');
    selectedSubfolderId = null;
    selectedSubfolderName = null;
    currentFolderId = '';
    lastCollabResponse = null;
    lastContactData = null;
    currentDealList = [];
    currentSelectedDeal = null;
    rootFolderId = '';
    currentFolderSuggestions = [];
    currentSuggestionCursor = null;
    currentHighlightedEmail = null;
    if (metadataStatus) {
      metadataStatus.textContent = '';
    }
    updateSuggestionNavigation(null);
    updateDealButtonState();
  }

  async function fetchJSON(url, options) {
    let resp;
    try {
      resp = await fetch(url, options);
    } catch (networkError) {
      const error = new Error('Network error while contacting the server');
      error.detail = { network: true, original: String(networkError) };
      throw error;
    }

    const contentType = resp.headers.get('content-type') || '';
    let rawText = '';
    try {
      rawText = await resp.text();
    } catch (bodyError) {
      const error = new Error('Failed to read response body');
      error.detail = { original: String(bodyError) };
      error.status = resp.status;
      throw error;
    }

    let data = null;
    if (contentType.includes('application/json') && rawText) {
      try {
        data = JSON.parse(rawText);
      } catch (parseError) {
        const error = new Error('Invalid JSON response received');
        error.detail = { raw: rawText };
        error.status = resp.status;
        throw error;
      }
    }

    if (!resp.ok) {
      const error = new Error(data?.message || 'Request failed');
      error.detail = data || (rawText ? { raw: rawText } : {});
      error.status = resp.status;
      throw error;
    }

    if (data !== null) {
      return data;
    }
    return rawText ? { raw: rawText } : {};
  }

  async function fetchContactDetails(email) {
    const trimmed = (email || '').trim();
    if (!trimmed) {
      return null;
    }
    const url = new URL('/box/collaborators/contact', window.location.origin);
    url.searchParams.set('email', trimmed);
    try {
      return await fetchJSON(url);
    } catch (error) {
      if (error.status === 404) {
        return null;
      }
      throw error;
    }
  }

  function normalizeFolderId(raw) {
    const value = (raw || '').trim();
    if (!value) return '';
    const urlMatch = value.match(/(?:folder=|folders\/|folder\/)(\d{5,})/i);
    if (urlMatch) {
      return urlMatch[1];
    }
    const idMatch = value.match(/(\d{5,})/);
    return idMatch ? idMatch[1] : value;
  }

  async function suggestFolder() {
    if (!suggestFolderButton) return;
    setBusy(suggestFolderButton, true, 'Searching…');
    statusText.textContent = 'Searching for a client folder without metadata…';
    if (folderSuggestionNote) folderSuggestionNote.innerHTML = '';
    errorCard.classList.add('hidden');
    try {
      const data = await fetchJSON('/_public/box/folder/missing-metadata');
      const issues = Array.isArray(data.issues) ? data.issues : [];
      const folders = Array.isArray(data.folders)
        ? data.folders
        : (data.folder ? [data.folder] : []);
      resetUI();
      renderFolderSuggestions(folders, issues, data.message, { nextCursor: data.next_cursor });
    } catch (error) {
      showError(error);
    } finally {
      setBusy(suggestFolderButton, false);
    }
  }

  async function fetchCollaboratorsData(folderId, options = {}) {
    const opts = typeof options === 'object' && options !== null ? options : {};
    const subfolderId = typeof opts.subfolderId === 'string' ? opts.subfolderId : '';
    const subfolderName = typeof opts.subfolderName === 'string' ? opts.subfolderName : '';
    const url = new URL('/box/folder/collaborators', window.location.origin);
    url.searchParams.set('folder_id', folderId);
    if (subfolderId) {
      url.searchParams.set('subfolder_id', subfolderId);
      if (subfolderName) {
        url.searchParams.set('subfolder', subfolderName);
      }
    }
    return fetchJSON(url);
  }

  function escapeHtml(value) {
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function resetCollaboratorAggregation() {
    collaboratorRegistry = new Map();
    renderAggregatedCollaborators();
  }

  function registerCollaborator(collab, context) {
    const emailRaw = (collab.email || '').trim();
    if (!emailRaw) {
      return;
    }
    const key = emailRaw.toLowerCase();
    const isExternal = !key.endsWith(pivotDomain);
    let entry = collaboratorRegistry.get(key);
    if (!entry) {
      entry = {
        key,
        email: emailRaw,
        names: new Set(),
        roles: new Set(),
        statuses: new Set(),
        labels: new Set(),
        sources: [],
        isExternal,
        hubspotStatus: isExternal ? 'pending' : 'idle',
        hubspotData: null,
        error: null,
        warnings: [],
      };
      collaboratorRegistry.set(key, entry);
    }
    entry.email = entry.email || emailRaw;
    if (isExternal) {
      entry.isExternal = true;
      if (entry.hubspotStatus === 'idle') {
        entry.hubspotStatus = 'pending';
      }
    }
    if (collab.name) {
      entry.names.add(collab.name);
    }
    if (collab.role) {
      entry.roles.add(collab.role);
      entry.labels.add(collab.role);
    }
    if (collab.status) {
      entry.statuses.add(collab.status);
    }
    const labels = Array.isArray(collab.association_labels) ? collab.association_labels : [];
    labels.forEach((label) => {
      if (label) {
        entry.labels.add(label);
      }
    });
    const sourceLabel = context.subfolderName || context.folderName || context.folderId || 'Folder';
    const sourceKey = `${context.folderId || ''}|${context.subfolderId || ''}|${sourceLabel}`;
    if (!entry.sources.some((src) => src.key === sourceKey)) {
      entry.sources.push({
        key: sourceKey,
        folderId: context.folderId || '',
        folderName: context.folderName || '',
        subfolderId: context.subfolderId || '',
        subfolderName: context.subfolderName || '',
        label: sourceLabel,
      });
    }
  }

  function highlightCollaboratorRow(email, options = {}) {
    const normalized = (email || '').trim().toLowerCase();
    currentHighlightedEmail = normalized || null;
    if (!collabTableBody) {
      return;
    }
    const rows = Array.from(collabTableBody.querySelectorAll('tr[data-email]'));
    rows.forEach((row) => {
      const match = row.dataset.email === normalized && normalized;
      row.classList.toggle('selected', Boolean(match));
    });
    if (!options.silent && normalized && statusText) {
      const message = options.message || `HubSpot details loaded for ${normalized}`;
      statusText.textContent = message;
    }
  }

  function clearSummaryCard() {
    if (summaryFolder) summaryFolder.innerHTML = '—';
    if (summaryPrimary) summaryPrimary.innerHTML = '—';
    if (summarySpouse) summarySpouse.innerHTML = '—';
    if (summaryMetadataBody) {
      summaryMetadataBody.innerHTML = '<tr><td colspan="2">No metadata fields populated.</td></tr>';
    }
    if (summaryCard) summaryCard.classList.add('hidden');
  }

  function buildContactSummary(contact) {
    if (!contact) {
      return '—';
    }
    const name =
      contact.name ||
      [contact.firstname, contact.lastname].filter(Boolean).join(' ').trim();
    const parts = [];
    if (name) {
      parts.push(`<strong>${escapeHtml(name)}</strong>`);
    }
    if (contact.email) {
      parts.push(`<span class="muted small">${escapeHtml(contact.email)}</span>`);
    }
    if (contact.id) {
      parts.push(`<span class="muted small">ID: ${escapeHtml(contact.id)}</span>`);
    }
    if (contact.link) {
      parts.push(
        `<a href="${escapeHtml(contact.link)}" target="_blank" rel="noopener">HubSpot</a>`,
      );
    }
    return parts.length ? parts.join('<br/>') : '—';
  }

  function isMetadataValueEmpty(value) {
    if (value === null || value === undefined) {
      return true;
    }
    if (typeof value === 'string') {
      return value.trim() === '';
    }
    if (Array.isArray(value)) {
      return value.length === 0;
    }
    if (typeof value === 'object') {
      return Object.keys(value).length === 0;
    }
    return false;
  }

  function formatMetadataValue(value) {
    if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
      return '<span class="muted small">—</span>';
    }
    if (typeof value === 'object') {
      try {
        const serialized = JSON.stringify(value, null, 2);
        return `<pre>${escapeHtml(serialized)}</pre>`;
      } catch (error) {
        return `<pre>${escapeHtml(String(value))}</pre>`;
      }
    }
    return escapeHtml(String(value));
  }

  function buildMetadataTableRows(fields) {
    const entries = Object.entries(fields || {}).filter(([, value]) => !isMetadataValueEmpty(value));
    if (!entries.length) {
      return '<tr><td colspan="2">No metadata fields populated.</td></tr>';
    }
    return entries
      .map(
      ([key, value]) =>
          `<tr><td>${escapeHtml(key)}</td><td>${formatMetadataValue(value)}</td></tr>`,
      )
      .join('');
  }

  function updateSummaryCard(previewData) {
    if (
      !summaryCard ||
      !summaryFolder ||
      !summaryPrimary ||
      !summarySpouse ||
      !summaryMetadataBody
    ) {
      return false;
    }
    if (!previewData) {
      clearSummaryCard();
      return false;
    }

    const folderName =
      currentFolderInfo?.name ||
      currentFolderInfo?.path ||
      currentFolderInfo?.id ||
      previewData.folder_id ||
      '—';
    const folderUrl = currentFolderInfo?.url || '';
    summaryFolder.innerHTML = folderUrl
      ? `<a href="${escapeHtml(folderUrl)}" target="_blank" rel="noopener">${escapeHtml(folderName)}</a>`
      : escapeHtml(folderName);

    const primary = previewData.contacts?.primary || {};
    summaryPrimary.innerHTML = buildContactSummary(primary);

    const spouse = previewData.contacts?.spouse || {};
    summarySpouse.innerHTML = buildContactSummary(spouse);

    const metadataRows = buildMetadataTableRows(previewData.metadata_fields);
    const hasMetadataContent = Object.entries(previewData.metadata_fields || {}).some(
      ([, value]) => !isMetadataValueEmpty(value),
    );
    summaryMetadataBody.innerHTML = metadataRows;
    summaryCard.classList.remove('hidden');
    return hasMetadataContent;
  }


  function revealFirstLoadedCollaborator(auto = false) {
    const entry = Array.from(collaboratorRegistry.values()).find(
      (item) => item.isExternal && item.hubspotStatus === 'loaded' && item.hubspotData,
    );
    if (!entry) {
      return;
    }
    renderContactDetails(entry.hubspotData);
    highlightCollaboratorRow(entry.email, {
      silent: !auto,
      message: `Auto-loaded HubSpot details for ${entry.email}`,
    });
    if (statusText && auto) {
      statusText.textContent = `Auto-loaded HubSpot details for ${entry.email}`;
    }
  }

  function renderAggregatedCollaborators() {
    if (!collabTableBody || !resultsWrapper) {
      return;
    }
    const entries = Array.from(collaboratorRegistry.values());
    const externalEntries = entries.filter((entry) => entry.isExternal);
    const totalCount = entries.length;
    const externalCount = externalEntries.length;
    collabTotal.textContent = String(totalCount);
    externalTotal.textContent = String(externalCount);

    const folderLabel =
      currentFolderInfo && (currentFolderInfo.name || currentFolderInfo.path || currentFolderInfo.id)
        ? `Inspecting ${currentFolderInfo.name || currentFolderInfo.path || `folder ${currentFolderInfo.id}`}`
        : 'Aggregated collaborators';

    if (!externalCount) {
      collabTableBody.innerHTML = '<tr><td colspan="5" class="muted">No external collaborators detected.</td></tr>';
      summaryTarget.textContent = `${folderLabel} · No external collaborators detected (internal collaborators hidden)`;
      resultsWrapper.classList.remove('hidden');
      return;
    }

    const sorted = externalEntries.sort((a, b) => a.email.localeCompare(b.email));

    const rows = sorted
      .map((entry) => {
        const names = Array.from(entry.names).join(' / ') || '—';
        const roles =
          Array.from(entry.labels).join(', ') ||
          Array.from(entry.roles).join(', ') ||
          '—';
        const statuses = Array.from(entry.statuses).join(', ') || '—';
        const sourceLabels = entry.sources.length
          ? entry.sources
              .map(
                (src) =>
                  src.subfolderName ||
                  src.folderName ||
                  src.label ||
                  src.folderId ||
                  src.subfolderId,
              )
              .join(', ')
          : 'Folder';
        let hubspotStatus = 'HubSpot lookup pending';
        if (entry.hubspotStatus === 'loaded') {
          hubspotStatus = 'HubSpot loaded';
        } else if (entry.hubspotStatus === 'error') {
          hubspotStatus = `HubSpot error${entry.error ? `: ${escapeHtml(entry.error)}` : ''}`;
        } else if (entry.hubspotStatus === 'not_found') {
          hubspotStatus = 'No HubSpot contact';
        }
        const detailParts = [];
        if (sourceLabels) {
          detailParts.push(`Folders: ${sourceLabels}`);
        }
        if (hubspotStatus) {
          detailParts.push(hubspotStatus);
        }
        const statusDetail = `${escapeHtml(statuses)}<br/><span class="muted small">${escapeHtml(
          detailParts.join(' · '),
        )}</span>`;
        return `
          <tr class="external" data-email="${escapeHtml(entry.email.toLowerCase())}">
            <td>${escapeHtml(entry.email)}</td>
            <td>${escapeHtml(names)}</td>
            <td>${escapeHtml(roles)}</td>
            <td>${statusDetail}</td>
            <td><button type="button" class="secondary hubspot-btn" data-email="${escapeHtml(
              entry.email,
            )}">HubSpot Details</button></td>
          </tr>
        `;
      })
      .join('');

    collabTableBody.innerHTML = rows;
    const externalLabel = externalCount === 1 ? 'external collaborator' : 'external collaborators';
    const hiddenNote = totalCount > externalCount ? ' (internal collaborators hidden)' : '';
    summaryTarget.textContent = `${folderLabel} · ${externalCount} ${externalLabel}${hiddenNote}`;
    resultsWrapper.classList.remove('hidden');
    if (currentHighlightedEmail) {
      highlightCollaboratorRow(currentHighlightedEmail, { silent: true });
    }
  }

  function collectCollaboratorsFromResponse(data, context) {
    if (!data) {
      return;
    }
    const collaborators = Array.isArray(data.collaborators) ? data.collaborators : [];
    collaborators.forEach((collab) => registerCollaborator(collab, context));
    renderAggregatedCollaborators();
  }

  async function scanSubfoldersForCollaborators(folderId, subfolders, scanToken, folderName) {
    if (!Array.isArray(subfolders) || !subfolders.length) {
      return;
    }
    for (const sub of subfolders) {
      if (scanToken !== currentCollaboratorScanToken) {
        return;
      }
      if (statusText) {
        statusText.textContent = `Scanning ${sub.name || sub.id} for collaborators…`;
      }
      try {
        const data = await fetchCollaboratorsData(folderId, { subfolderId: sub.id, subfolderName: sub.name });
        collectCollaboratorsFromResponse(data, {
          folderId,
          folderName,
          subfolderId: sub.id,
          subfolderName: sub.name,
        });
      } catch (error) {
        console.warn('Failed to scan subfolder', sub.id, error);
      }
      if (scanToken !== currentCollaboratorScanToken) {
        return;
      }
    }
  }

  async function loadHubspotDetailsForExternalCollaborators(scanToken) {
    if (scanToken !== currentCollaboratorScanToken) {
      return;
    }
    const entries = Array.from(collaboratorRegistry.values()).filter((entry) => entry.isExternal);
    if (!entries.length) {
      return;
    }
    if (statusText) {
      statusText.textContent = 'Loading HubSpot details for external collaborators…';
    }
    for (const entry of entries) {
      if (scanToken !== currentCollaboratorScanToken) {
        return;
      }
      if (entry.hubspotStatus !== 'pending') {
        continue;
      }
      entry.hubspotStatus = 'loading';
      renderAggregatedCollaborators();
      try {
        const data = await fetchContactDetails(entry.email);
        if (scanToken !== currentCollaboratorScanToken) {
          return;
        }
        if (data) {
          entry.hubspotStatus = 'loaded';
          entry.hubspotData = data;
          entry.warnings = Array.isArray(data.warnings) ? data.warnings : [];
        } else {
          entry.hubspotStatus = 'not_found';
        }
      } catch (error) {
        entry.hubspotStatus = 'error';
        entry.error = error.message || String(error);
      }
      if (scanToken !== currentCollaboratorScanToken) {
        return;
      }
      renderAggregatedCollaborators();
    }
    revealFirstLoadedCollaborator(true);
  }

  async function autoProcessFolder(folderId, rootData) {
    const scanToken = ++currentCollaboratorScanToken;
    const folderName =
      (rootData?.root_folder && rootData.root_folder.name) ||
      (rootData?.folder && rootData.folder.name) ||
      (rootData?.inspected && rootData.inspected.name) ||
      '';
    collectCollaboratorsFromResponse(rootData, { folderId, folderName });
    const subfolders = await loadSubfolders({ folderId, auto: true, suppressStatus: true });
    await scanSubfoldersForCollaborators(folderId, subfolders, scanToken, folderName);
    await loadHubspotDetailsForExternalCollaborators(scanToken);
    if (scanToken === currentCollaboratorScanToken && statusText) {
      statusText.textContent = 'Collaborator scan complete.';
    }
  }

  async function autoStartForPresetFolder() {
    if (!presetFolderId) {
      return;
    }
    try {
      if (statusText) {
        statusText.textContent = 'Loading preset folder…';
      }
      await showCollaborators(null, presetFolderId, null, null, { auto: true, suppressStatus: true });
    } catch (error) {
      showError(error);
    }
  }

function renderFolderSuggestions(folders, issues, message, options = {}) {
  if (!folderSuggestionNote) return;

  const { append = false, nextCursor = null } = options;

  const cleaned = Array.isArray(folders)
    ? folders.filter((folder) => folder && (folder.id || folder.name))
    : [];

  const existingKeys = new Set(
    currentFolderSuggestions.map((folder) => (folder.id || folder.name || '').toString().trim())
  );

  const newEntries = [];
  cleaned.forEach((folder) => {
    const key = (folder.id || folder.name || '').toString().trim();
    if (!key || existingKeys.has(key)) {
      return;
    }
    existingKeys.add(key);
    newEntries.push(folder);
  });

  if (!append) {
    folderSuggestionNote.innerHTML = '';
    currentFolderSuggestions = [];
    currentFolderInfo = {};
    updateFolderSummary();
  }

  let intro = folderSuggestionNote.querySelector('.suggestion-intro');
  if (!intro) {
    intro = document.createElement('div');
    intro.className = 'suggestion-intro muted small';
    folderSuggestionNote.appendChild(intro);
  }
  intro.textContent = message || 'Select a folder below to load collaborators.';

  let list = folderSuggestionNote.querySelector('.suggestion-list');
  if (!list) {
    list = document.createElement('div');
    list.className = 'suggestion-list';
    folderSuggestionNote.appendChild(list);
  }

  const startIndex = append ? currentFolderSuggestions.length : 0;

  newEntries.forEach((folder, offset) => {
    const globalIndex = startIndex + offset;
    const checkboxId = `folder-suggestion-${globalIndex}`;
    const item = document.createElement('label');
    item.className = 'suggestion-item';
    item.setAttribute('for', checkboxId);

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.dataset.suggestionIndex = String(globalIndex);

    const info = document.createElement('div');
    const folderId = normalizeFolderId(folder.id || '');
    const displayName = folder.name || folderId || `Folder ${globalIndex + 1}`;
    const linkUrl = (folder.url || '').trim();
    const path = (folder.path || '').trim();

    const titleLine = document.createElement('div');
    const title = document.createElement('strong');
    title.textContent = displayName;
    titleLine.appendChild(title);
    if (linkUrl) {
      titleLine.appendChild(document.createTextNode(' · '));
      const anchor = document.createElement('a');
      anchor.href = linkUrl;
      anchor.target = '_blank';
      anchor.rel = 'noopener';
      anchor.textContent = 'Open';
      titleLine.appendChild(anchor);
    }
    info.appendChild(titleLine);

    if (path || folderId) {
      const detailLine = document.createElement('div');
      detailLine.className = 'muted small';
      detailLine.textContent = path || `ID: ${folderId}`;
      info.appendChild(detailLine);
    }

    item.appendChild(checkbox);
    item.appendChild(info);
    list.appendChild(item);

    checkbox.addEventListener('change', async (event) => {
      if (!event.target.checked) {
        item.classList.remove('highlight');
        return;
      }
      list.querySelectorAll('input[data-suggestion-index]').forEach((input) => {
        if (input !== event.target) {
          input.checked = false;
          if (input.parentElement) {
            input.parentElement.classList.remove('highlight');
          }
        }
      });
      item.classList.add('highlight');
      const indexValue = Number(event.target.dataset.suggestionIndex);
      if (!Number.isNaN(indexValue)) {
        await handleFolderSuggestionSelection(indexValue);
      }
    });
  });

  if (newEntries.length) {
    currentFolderSuggestions = append
      ? currentFolderSuggestions.concat(newEntries)
      : newEntries;
  } else if (!append) {
    currentFolderSuggestions = [];
  }

  let issuesWrapper = folderSuggestionNote.querySelector('.suggestion-issues-wrapper');
  if (!issuesWrapper) {
    issuesWrapper = document.createElement('div');
    issuesWrapper.className = 'suggestion-issues-wrapper hidden';
    folderSuggestionNote.appendChild(issuesWrapper);
  }
  if (!append) {
    issuesWrapper.innerHTML = '';
  }
  if (Array.isArray(issues) && issues.length) {
    const issueList = document.createElement('ul');
    issueList.className = 'suggestion-issues';
    issues.forEach((msg) => {
      const li = document.createElement('li');
      li.textContent = msg;
      issueList.appendChild(li);
    });
    issuesWrapper.appendChild(issueList);
  }
  if (issuesWrapper.innerHTML.trim()) {
    issuesWrapper.classList.remove('hidden');
  } else {
    issuesWrapper.classList.add('hidden');
  }

  if (!currentFolderSuggestions.length) {
    intro.textContent = message || 'No untagged folders found.';
    if (list) {
      list.innerHTML = '';
    }
  }

  updateSuggestionNavigation(nextCursor);

  if (statusText) {
    if (append) {
      if (newEntries.length) {
        statusText.textContent = 'Additional untagged folders loaded.';
      } else {
        statusText.textContent = message || 'No more untagged folders found.';
      }
    } else {
      statusText.textContent = currentFolderSuggestions.length
        ? 'Select a folder to continue.'
        : (message || 'No untagged folders found.');
    }
  }
}

  function updateSuggestionNavigation(nextCursor) {
    if (typeof nextCursor === 'number' && nextCursor >= 0) {
      currentSuggestionCursor = nextCursor;
    } else if (typeof nextCursor === 'string' && nextCursor.trim() !== '') {
      const parsed = Number(nextCursor);
      currentSuggestionCursor = Number.isNaN(parsed) ? nextCursor : parsed;
    } else {
      currentSuggestionCursor = null;
    }

    if (!loadMoreSuggestionsButton) {
      return;
    }

    if (currentSuggestionCursor !== null && currentSuggestionCursor !== '') {
      loadMoreSuggestionsButton.classList.remove('hidden');
      loadMoreSuggestionsButton.disabled = false;
      loadMoreSuggestionsButton.textContent = loadMoreSuggestionsButton.dataset.default || 'Show Next 5';
    } else {
      loadMoreSuggestionsButton.classList.add('hidden');
    }
  }

  async function loadNextSuggestions() {
    if (currentSuggestionCursor === null || currentSuggestionCursor === undefined || currentSuggestionCursor === '') {
      statusText.textContent = 'No additional untagged folders available.';
      return;
    }
    if (!loadMoreSuggestionsButton) {
      return;
    }
    setBusy(loadMoreSuggestionsButton, true, 'Loading…');
    try {
      const params = new URLSearchParams();
      params.set('cursor', String(currentSuggestionCursor));
      const data = await fetchJSON(`/_public/box/folder/missing-metadata?${params.toString()}`);
      const folders = Array.isArray(data.folders)
        ? data.folders
        : (data.folder ? [data.folder] : []);
      const issues = Array.isArray(data.issues) ? data.issues : [];
      renderFolderSuggestions(folders, issues, data.message, { append: true, nextCursor: data.next_cursor });
    } catch (error) {
      showError(error);
    } finally {
      setBusy(loadMoreSuggestionsButton, false);
    }
  }

  async function handleFolderSuggestionSelection(index) {
    const suggestion = currentFolderSuggestions[index];
    if (!suggestion) {
      return;
    }
    const folderId = normalizeFolderId(suggestion.id || '');
    if (!folderId) {
      statusText.textContent = 'Selected folder does not have a valid id.';
      return;
    }

    const name = suggestion.name || folderId;
    folderInput.value = folderId;
    rootFolderId = folderId;
    currentFolderId = folderId;
    selectedSubfolderId = null;
    selectedSubfolderName = null;
    statusText.textContent = `Loading collaborators for ${name}…`;

    const inputs = folderSuggestionNote
      ? Array.from(folderSuggestionNote.querySelectorAll('input[data-suggestion-index]'))
      : [];
    inputs.forEach((input) => {
      input.disabled = true;
    });
    try {
      await showCollaborators(null, folderId, null, null, { auto: true });
    } finally {
      inputs.forEach((input) => {
        input.disabled = false;
      });
    }
  }

  async function loadSubfolders(options = {}) {
    if (options instanceof Event) {
      options = {};
    }
    const opts = typeof options === 'object' && options !== null ? options : {};
    const auto = Boolean(opts.auto);
    const suppressStatus = Boolean(opts.suppressStatus);
    const providedId = typeof opts.folderId === 'string' ? opts.folderId : '';
    const rawFolderValue = providedId || folderInput.value.trim();
    const folderId = normalizeFolderId(rawFolderValue);
    if (!folderId) {
      if (!auto) {
        statusText.textContent = 'Validation error · folder id required';
      }
      return [];
    }

    if (!providedId && folderId !== rawFolderValue) {
      folderInput.value = folderId;
    }

    const busyTarget = auto ? null : loadSubfoldersButton;
    if (busyTarget) {
      setBusy(busyTarget, true, 'Loading…');
    }
    errorCard.classList.add('hidden');

    let fetchedSubfolders = [];
    try {
      const url = new URL('/box/folder/subfolders', window.location.origin);
      url.searchParams.set('folder_id', folderId);
      const data = await fetchJSON(url);
      currentFolderId = folderId;
      rootFolderId = folderId;
      fetchedSubfolders = Array.isArray(data.subfolders) ? data.subfolders : [];
      renderSubfolders(fetchedSubfolders, folderId);
      if (!auto && !suppressStatus) {
        statusText.textContent = (data.subfolders || []).length
          ? 'Select a subfolder then choose Show Collaborators.'
          : 'No subfolders found for this folder.';
      }
    } catch (error) {
      if (auto) {
        const detail = error && error.message ? error.message : 'Unknown error';
        statusText.textContent = `Subfolder load failed · ${detail}`;
        console.error('Automatic subfolder load failed:', error);
      } else {
        showError(error);
      }
      return [];
    } finally {
      if (busyTarget) {
        setBusy(busyTarget, false);
      }
    }
    return fetchedSubfolders;
  }

  function renderSubfolders(subfolders, folderId, activeSubfolderId) {
    subfolderWrapper.classList.remove('hidden');
    subfolderList.innerHTML = '';
    currentFolderId = folderId;

    const targetSubfolderId = activeSubfolderId || selectedSubfolderId || null;
    selectedSubfolderId = null;
    selectedSubfolderName = null;

    if (Array.isArray(subfolders) && subfolders.length) {
      subfolderActions.classList.remove('hidden');
      subfolders.forEach((child) => {
        const item = document.createElement('label');
        item.className = 'subfolder-item';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = child.id;
        checkbox.dataset.name = child.name;
        checkbox.addEventListener('change', () => {
          if (!checkbox.checked) {
            selectedSubfolderId = null;
            selectedSubfolderName = null;
            return;
          }
          subfolderList.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
            if (cb !== checkbox) cb.checked = false;
          });
          selectedSubfolderId = child.id;
          selectedSubfolderName = child.name;
          currentFolderId = folderId;
        });
        const text = document.createElement('span');
        text.innerHTML = `<strong>${child.name || 'Untitled'}</strong> <small class="muted">(#${child.id})</small>`;
        item.appendChild(checkbox);
        item.appendChild(text);
        subfolderList.appendChild(item);

        if (targetSubfolderId && targetSubfolderId === String(child.id)) {
          checkbox.checked = true;
          selectedSubfolderId = String(child.id);
          selectedSubfolderName = child.name || null;
          statusText.textContent = `Selected subfolder ${selectedSubfolderName || selectedSubfolderId}`;
        }
      });
      subfolderList.classList.remove('hidden');
      subfolderEmpty.classList.add('hidden');
    } else {
      subfolderList.classList.add('hidden');
      subfolderEmpty.classList.remove('hidden');
      subfolderActions.classList.add('hidden');
    }
  }

  async function showCollaborators(button, folderId, subfolderId, subfolderName, options = {}) {
    const opts = typeof options === 'object' && options !== null ? options : {};
    const auto = Boolean(opts.auto);
    const suppressStatus = Boolean(opts.suppressStatus);
    const skipBusy = Boolean(opts.skipBusy) || auto;
    const normalizedFolderId = normalizeFolderId(folderId);
    if (normalizedFolderId !== folderId) {
      folderId = normalizedFolderId;
      folderInput.value = folderId;
    }

    if (!folderId) {
      statusText.textContent = 'Validation error · folder id required';
      return;
    }

    if (!subfolderId) {
      rootFolderId = folderId;
    }

    if (!skipBusy && button) {
      setBusy(button, true, 'Loading…');
    }
    errorCard.classList.add('hidden');

    try {
      const data = await fetchCollaboratorsData(folderId, { subfolderId, subfolderName });
      currentFolderId = folderId;
      if (!rootFolderId) {
        rootFolderId = folderId;
      }
      renderCollaborators(data);
      rootFolderId = data.folder_id || rootFolderId || folderId;
      if (!suppressStatus) {
        statusText.textContent = `Success · ${data.total} collaborators found`;
      }
      if (auto && !subfolderId) {
        await autoProcessFolder(folderId, data);
      }
      return data;
    } catch (error) {
      showError(error);
    } finally {
      if (!skipBusy && button) {
        setBusy(button, false);
      }
    }
  }

  function renderCollaborators(data) {
    lastCollabResponse = data || null;
    lastContactData = null;
    contactCard.classList.add('hidden');
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    if (metadataActions) {
      metadataActions.classList.add('hidden');
      metadataStatus.textContent = '';
      metadataButton.disabled = false;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
   if (dealCard) dealCard.classList.add('hidden');
    currentDealList = [];
    currentSelectedDeal = null;

    resetCollaboratorAggregation();

    if (!data) {
      summaryTarget.textContent = 'No collaborator data available.';
      updateFolderSummary();
      updateDealButtonState();
      return;
    }

    const collaborators = Array.isArray(data.collaborators) ? data.collaborators : [];

    if (data.root_folder) {
      currentFolderInfo = {
        id: data.root_folder.id || data.folder_id || '',
        name: data.root_folder.name || '',
        url: data.root_folder.url || '',
        path: data.root_folder.path || '',
      };
    } else {
      currentFolderInfo = {
        id: data.folder_id || '',
        name: data.folder?.name || data.inspected?.name || '',
        url: data.folder?.url || '',
      };
    }
    updateFolderSummary();

    const context = {
      folderId: data.folder_id || data.target_folder_id || currentFolderId || '',
      folderName:
        (data.root_folder && data.root_folder.name) ||
        (data.folder && data.folder.name) ||
        (data.inspected && data.inspected.name) ||
        '',
      subfolderId:
        data.inspected && data.inspected.id && data.inspected.id !== (data.folder_id || data.target_folder_id)
          ? data.inspected.id
          : '',
      subfolderName: (data.inspected && data.inspected.name) || '',
    };

    collectCollaboratorsFromResponse(data, context);

    contactCard.classList.add('hidden');
    contactDetails.textContent = 'Select a collaborator to load HubSpot details.';
    resultsWrapper.classList.remove('hidden');
    updateFolderSummary();
    updateDealButtonState();
  }

  function renderContactDetails(data) {
    if (!data || !data.contact) {
      lastContactData = null;
      contactDetails.textContent = 'No HubSpot details found.';
      contactCard.classList.remove('hidden');
      if (metadataActions) {
        metadataActions.classList.add('hidden');
        metadataStatus.textContent = 'Metadata creation requires contact and deal context.';
      }
      if (metadataPreviewButton) {
        metadataPreviewButton.disabled = true;
      }
      if (metadataPreview) {
        metadataPreview.classList.add('hidden');
      }
      if (metadataPreviewContent) {
        metadataPreviewContent.textContent = '';
      }
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    updateDealButtonState();
    return;
  }

    lastContactData = data;
    const contact = data.contact;
    const props = contact.properties || {};
    const deals = data.deals || [];
    const warnings = Array.isArray(data.warnings) ? data.warnings : [];

    let html = '<table><tbody>';
    html += `<tr><th>ID</th><td>${contact.id || '—'}</td></tr>`;
    html += `<tr><th>Name</th><td>${props.firstname || ''} ${props.lastname || ''}</td></tr>`;
    html += `<tr><th>Email</th><td>${props.email || '—'}</td></tr>`;
    html += `<tr><th>Phone</th><td>${props.phone || '—'}</td></tr>`;
    if (contact.url) {
      html += `<tr><th>HubSpot</th><td><a href="${contact.url}" target="_blank" rel="noopener">Open Contact</a></td></tr>`;
    }
    html += '</tbody></table>';

    contactDetails.innerHTML = html;
    contactCard.classList.remove('hidden');
    if (metadataActions) {
      metadataActions.classList.remove('hidden');
      metadataStatus.textContent = deals.length
        ? 'Tick a checkbox next to a deal before applying metadata.'
        : 'No associated deals found. You will be prompted for details before applying.';
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    renderWarnings(warnings);
    renderDealList(deals);
    updateDealButtonState();
  }

  async function createMetadata() {
    if (!metadataButton) {
      return;
    }

    const folderValue = rootFolderId
      || (lastCollabResponse && lastCollabResponse.inspected && lastCollabResponse.inspected.id)
      || currentFolderId
      || folderInput.value.trim();
    const folderId = normalizeFolderId(folderValue);
    if (!folderId) {
      metadataStatus.textContent = 'Folder id is unavailable. Load collaborators first.';
      return;
    }
    if (folderId !== folderValue) {
      folderInput.value = folderId;
    }

    let selectedDeal = currentSelectedDeal;
    let dealId = '';
    if (!selectedDeal) {
      const manual = window.prompt('Enter HubSpot deal id for metadata tagging');
      if (manual === null) {
        metadataStatus.textContent = 'Metadata creation cancelled.';
        return;
      }
      dealId = (manual || '').trim();
      if (!dealId) {
        metadataStatus.textContent = 'Deal id is required to apply metadata.';
        return;
      }
      if (metadataStatus) {
        metadataStatus.textContent = 'Using manually supplied deal id.';
      }
      const possibleDeals = Array.isArray(lastContactData?.deals) ? lastContactData.deals : [];
      selectedDeal = possibleDeals.find((deal) => {
        const props = deal.properties || {};
        return props.hs_deal_record_id === dealId || String(deal.id) === dealId;
      }) || null;
      if (selectedDeal) {
        currentSelectedDeal = selectedDeal;
      }
      if (dealMessage) {
        dealMessage.textContent = selectedDeal
          ? `Using ${selectedDeal.properties?.dealname || dealId}`
          : `Using manual deal id ${dealId}`;
      }
    } else {
      const dealProps = selectedDeal.properties || {};
      dealId = String(dealProps.hs_deal_record_id || selectedDeal.id || '').trim();
      if (!dealId) {
        metadataStatus.textContent = 'Selected deal is missing an id; please choose another deal.';
        return;
      }
    }

    const payload = {
      folder_id: folderId,
      deal_id: dealId,
      hs_deal_record_id: dealId,
    };

    if (lastContactData && lastContactData.contact) {
      const contact = lastContactData.contact;
      const props = contact.properties || {};
      if (contact.id) payload.hs_contact_id = contact.id;
      if (props.firstname) payload.hs_contact_firstname = props.firstname;
      if (props.lastname) payload.hs_contact_lastname = props.lastname;
      if (props.email) payload.hs_contact_email = props.email;
    }

    if (selectedDeal && selectedDeal.properties) {
      const props = selectedDeal.properties;
      if (props.deal_salutation) payload.deal_salutation = props.deal_salutation;
      if (props.household_type) payload.household_type = props.household_type;
      if (props.hs_spouse_id) payload.hs_spouse_id = props.hs_spouse_id;
      if (props.hs_spouse_firstname) payload.hs_spouse_firstname = props.hs_spouse_firstname;
      if (props.hs_spouse_lastname) payload.hs_spouse_lastname = props.hs_spouse_lastname;
      if (props.hs_spouse_email) payload.hs_spouse_email = props.hs_spouse_email;
    }

    generateMetadataPreview(payload, selectedDeal);
    const confirmed = window.confirm('Apply metadata using the previewed values?');
    if (!confirmed) {
      metadataStatus.textContent = 'Metadata creation cancelled.';
      statusText.textContent = 'Metadata apply cancelled.';
      return;
    }

    statusText.textContent = 'Applying metadata…';
    metadataStatus.textContent = 'Applying metadata…';
    setBusy(metadataButton, true, 'Working…');

    try {
      const data = await fetchJSON('/box/folder/tag/auto', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });
      metadataStatus.textContent = `Metadata applied. Fields updated: ${data.metadata_fields.length}`;
      statusText.textContent = `Metadata applied to folder ${data.folder_id}`;
    } catch (error) {
      metadataStatus.textContent = `Metadata creation failed: ${error.message}`;
      statusText.textContent = `Metadata error · ${error.message}`;
      errorCard.classList.remove('hidden');
      const detailText = error.detail && Object.keys(error.detail).length
        ? `<br/><code>${JSON.stringify(error.detail, null, 2)}</code>`
        : '';
      errorCard.innerHTML = `<strong>Error:</strong> ${error.message}${detailText}`;
      console.error(error);
    } finally {
      setBusy(metadataButton, false);
    }
  }

  function showError(error) {
    const detail = error.detail || {};
    errorCard.classList.remove('hidden');
    const prettyDetail = detail && Object.keys(detail).length ? JSON.stringify(detail, null, 2) : '';
    errorCard.innerHTML = `<strong>Error:</strong> ${error.message}${prettyDetail ? `<br/><code>${prettyDetail}</code>` : ''}`;
    statusText.textContent = `Error · ${error.message}`;
    resultsWrapper.classList.add('hidden');
    contactCard.classList.add('hidden');
    if (dealCard) dealCard.classList.add('hidden');
    if (dealList) dealList.innerHTML = '';
    if (dealMessage) dealMessage.textContent = 'Tick the checkbox next to a deal to load metadata values.';
    currentFolderInfo = {};
    updateFolderSummary();
    if (metadataPreview) {
      metadataPreview.classList.add('hidden');
    }
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = '';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataWarningList) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
    }
    currentContactWarnings = new Map();
    clearSummaryCard();
    currentSuggestionCursor = null;
    updateSuggestionNavigation(null);
    updateDealButtonState();
    console.error(error);
  }

  if (loadSubfoldersButton) {
    loadSubfoldersButton.addEventListener('click', () => {
      loadSubfolders();
    });
  }

  if (loadMoreSuggestionsButton) {
    loadMoreSuggestionsButton.addEventListener('click', () => {
      loadNextSuggestions();
    });
  }

  if (suggestFolderButton) {
    suggestFolderButton.addEventListener('click', () => {
      suggestFolder();
    });
  }

  rootShowButton.addEventListener('click', () => {
    const folderId = folderInput.value.trim();
    showCollaborators(rootShowButton, folderId, selectedSubfolderId, selectedSubfolderName, { auto: true });
  });

  subfolderShowButton.addEventListener('click', () => {
    const folderId = currentFolderId || folderInput.value.trim();
    if (!selectedSubfolderId) {
      statusText.textContent = 'Select a subfolder before showing collaborators.';
      return;
    }
    showCollaborators(subfolderShowButton, folderId, selectedSubfolderId, selectedSubfolderName);
  });

  resetButton.addEventListener('click', () => {
    folderInput.value = '';
    resetUI();
    folderInput.focus();
  });

  subfolderList.addEventListener('click', (event) => {
    const checkbox = event.target.closest('input[type="checkbox"]');
    if (!checkbox) return;
    if (checkbox.checked) {
      statusText.textContent = `Selected subfolder ${checkbox.dataset.name || checkbox.value}`;
    }
  });

  collabTableBody.addEventListener('click', async (event) => {
    const button = event.target.closest('button[data-email]');
    if (!button) return;
    const email = button.dataset.email;
    if (!email || email === '—') {
      contactDetails.textContent = 'No email available for this collaborator.';
      contactCard.classList.remove('hidden');
      return;
    }

    setBusy(button, true, 'Loading…');
    try {
      const data = await fetchContactDetails(email);
      renderContactDetails(data);
      if (data && data.contact) {
        statusText.textContent = `Loaded HubSpot details for ${email}`;
        highlightCollaboratorRow(email, {
          message: `Loaded HubSpot details for ${email}`,
        });
      } else {
        statusText.textContent = `No HubSpot match for ${email}`;
      }
    } catch (error) {
      showError(error);
    } finally {
      setBusy(button, false);
    }
  });

  function handleEnterKey(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      rootShowButton.click();
    }
  }

  folderInput.addEventListener('keypress', handleEnterKey);

  if (metadataButton) {
    metadataButton.addEventListener('click', () => {
      createMetadata();
    });
  }

  if (metadataPreviewButton) {
    metadataPreviewButton.addEventListener('click', () => {
      if (!currentSelectedDeal) {
        metadataStatus.textContent = 'Select a deal before generating the metadata preview.';
        return;
      }
      generateMetadataPreview();
    });
  }

  if (metadataDealButton) {
    metadataDealButton.addEventListener('click', () => {
      updateDealBoxFolder();
    });
  }

  function renderWarnings(warnings, options = {}) {
    if (!metadataWarningList) {
      return;
    }
    const { append = false } = options;
    if (!append) {
      currentContactWarnings = new Map();
    }
    (Array.isArray(warnings) ? warnings : []).forEach((warning) => {
      if (!warning || !warning.message) {
        return;
      }
      const scope = warning.scope ? String(warning.scope) : '';
      const message = String(warning.message);
      const key = `${scope}|${message}`;
      if (!currentContactWarnings.has(key)) {
        currentContactWarnings.set(key, { scope, message });
      }
    });

    if (!currentContactWarnings.size) {
      metadataWarningList.classList.add('hidden');
      metadataWarningList.innerHTML = '';
      return;
    }

    metadataWarningList.classList.remove('hidden');
    const items = Array.from(currentContactWarnings.values()).map(({ scope, message }) => {
      const scopeLabel = scope ? `<strong>${scope.replace(/_/g, ' ')}:</strong> ` : '';
      return `<li>${scopeLabel}${message}</li>`;
    }).join('');
    metadataWarningList.innerHTML = `<p><strong>Warnings</strong></p><ul>${items}</ul>`;
  }

  function buildMetadataPreview(payload, deal, contact) {
    const primaryName = [payload.hs_contact_firstname, payload.hs_contact_lastname]
      .filter(Boolean)
      .join(' ')
      .trim();
    const spouseName = [payload.hs_spouse_firstname, payload.hs_spouse_lastname]
      .filter(Boolean)
      .join(' ')
      .trim();

    const portalId = extractPortalIdFromUrl(contact?.url);
    const primaryLink = contact?.url || buildContactLink(portalId, payload.hs_contact_id);
    const spouseLink = buildContactLink(portalId, payload.hs_spouse_id);

    const associatedIdSet = new Set();
    const associatedContacts = [];
    const seenContactKeys = new Set();

    const pushAssociatedContact = ({ name, email, id, link }) => {
      const trimmedId = (id || '').trim();
      const key = `${trimmedId}|${(email || name || '').toLowerCase()}`;
      if (key && seenContactKeys.has(key)) {
        return;
      }
      if (key) {
        seenContactKeys.add(key);
      }
      if (trimmedId) {
        associatedIdSet.add(trimmedId);
      }
      associatedContacts.push(
        formatAssociatedContact({
          name: name || 'Contact',
          email: email || '',
          id: trimmedId,
          link: link,
        })
      );
    };

    if (primaryName || payload.hs_contact_id || payload.hs_contact_email) {
      pushAssociatedContact({
        name: primaryName || 'Primary Contact',
        email: payload.hs_contact_email || '',
        id: payload.hs_contact_id || '',
        link: primaryLink,
      });
    }
    if (spouseName || payload.hs_spouse_id || payload.hs_spouse_email) {
      pushAssociatedContact({
        name: spouseName || 'Spouse',
        email: payload.hs_spouse_email || '',
        id: payload.hs_spouse_id || '',
        link: spouseLink,
      });
    }

    const metadataFields = {
      deal_salutation: payload.deal_salutation || '',
      household_type: payload.household_type || '',
      primary_contact_id: payload.hs_contact_id || '',
      primary_contact_link: primaryLink || '',
      hs_spouse_id: payload.hs_spouse_id || '',
      spouse_contact_link: spouseLink || '',
    };

    const dealDetails = (() => {
      if (!deal) return undefined;
      const props = deal.properties || {};
      return {
        id: props.hs_deal_record_id || deal.id || '',
        name: props.dealname || '',
        stage: props.dealstage || '',
        close_date: formatDate(extractDealTimestamp(deal)) || '',
      };
    })();

    return {
      folder_id: payload.folder_id,
      deal_id: payload.deal_id,
      deal: dealDetails,
      metadata_fields: metadataFields,
      contacts: {
        primary: {
          id: payload.hs_contact_id || '',
          name: primaryName || '',
          email: payload.hs_contact_email || '',
          link: primaryLink || '',
        },
        spouse: {
          id: payload.hs_spouse_id || '',
          name: spouseName || '',
          email: payload.hs_spouse_email || '',
          link: spouseLink || '',
          firstname: payload.hs_spouse_firstname || '',
          lastname: payload.hs_spouse_lastname || '',
        },
        additional: [],
      },
    };
  }

  function extractPortalIdFromUrl(url) {
    if (!url) return '';
    const match = String(url).match(/contacts\/(\d+)\/record/);
    return match ? match[1] : '';
  }

  function buildContactLink(portalId, contactId) {
    if (!portalId || !contactId) return undefined;
    return `https://app.hubspot.com/contacts/${portalId}/record/0-1/${contactId}`;
  }

  function formatAssociatedContact({ name, email, id, link }) {
    const parts = [];
    if (email) parts.push(email);
    if (id) parts.push(`ID: ${id}`);
    if (link) parts.push(`Link: ${link}`);
    if (!parts.length) return name || 'Contact';
    return `${name || 'Contact'} (${parts.join(' | ')})`;
  }

  function parseTimestamp(value) {
    if (!value && value !== 0) return 0;
    if (typeof value === 'number') return value;
    const str = String(value).trim();
    if (!str) return 0;
    if (/^\d+$/.test(str)) {
      const num = Number(str);
      if (Number.isNaN(num)) return 0;
      return num > 1e12 ? num : num * 1000;
    }
    const parsed = Date.parse(str);
    return Number.isNaN(parsed) ? 0 : parsed;
  }

  function extractDealTimestamp(deal) {
    const props = (deal && deal.properties) || {};
    const candidates = [
      props.agreement_start_date,
      props.closedate,
      props.hs_closed_won_date,
      deal?.updatedAt,
      deal?.createdAt,
    ];
    for (const candidate of candidates) {
      const ts = parseTimestamp(candidate);
      if (ts) return ts;
    }
    return 0;
  }

  function formatDate(ts) {
    if (!ts) return 'n/a';
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return 'n/a';
    return d.toISOString().slice(0, 10);
  }

  function similarityScore(a, b) {
    const src = (a || '').toLowerCase();
    const tgt = (b || '').toLowerCase();
    if (!src || !tgt) return 0;
    if (src === tgt) return 1;

    const bigrams = (text) => {
      const map = new Map();
      const normalized = text.replace(/[^a-z0-9]+/g, '');
      for (let i = 0; i < normalized.length - 1; i += 1) {
        const bg = normalized.slice(i, i + 2);
        map.set(bg, (map.get(bg) || 0) + 1);
      }
      return map;
    };

    const source = bigrams(src);
    const target = bigrams(tgt);
    if (!source.size || !target.size) return 0;

    let intersection = 0;
    let totalA = 0;
    let totalB = 0;
    source.forEach((count, key) => {
      totalA += count;
      if (target.has(key)) {
        intersection += Math.min(count, target.get(key));
      }
    });
    target.forEach((count) => {
      totalB += count;
    });

    const total = totalA + totalB;
    return total ? (2 * intersection) / total : 0;
  }

function renderDealList(deals) {
  if (!dealList || !dealCard) return;

  const sorted = Array.isArray(deals)
    ? [...deals].sort((a, b) => extractDealTimestamp(b) - extractDealTimestamp(a))
    : [];
  currentDealList = sorted;
  currentSelectedDeal = null;
  dealList.innerHTML = '';

  if (!sorted.length) {
    dealCard.classList.add('hidden');
    if (dealMessage) {
      dealMessage.textContent = 'No associated deals found.';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataDealButton) {
      metadataDealButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    currentSelectedDeal = null;
    clearSummaryCard();
    updateDealButtonState();
    return;
  }

  sorted.forEach((deal, index) => {
    const props = deal.properties || {};
    const displayId = props.hs_deal_record_id || deal.id || `deal-${index}`;
    const name = props.dealname || `Deal ${displayId}`;
    const stage = props.dealstage || 'Unknown stage';
    const agreementDate = formatDate(
      parseTimestamp(props.agreement_start_date) || extractDealTimestamp(deal)
    );
    const amount = props.amount ? `$${props.amount}` : '—';
    const contactsStatus = deal.associated_contacts_status || 'unknown';

    const checkboxId = `deal-choice-${index}`;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.name = 'deal-choice';
    checkbox.value = String(index);
    checkbox.dataset.dealIndex = String(index);
    checkbox.id = checkboxId;
    checkbox.addEventListener('change', (event) => {
      handleDealCheckboxChange(event, index);
    });

    const item = document.createElement('div');
    item.className = 'deal-item';
    item.appendChild(checkbox);

    const label = document.createElement('label');
    label.setAttribute('for', checkboxId);
    const details = [
      `Stage: ${stage}`,
      `Agreement: ${agreementDate}`,
      `Amount: ${amount}`,
    ];
    let infoHtml = `<strong>${name}</strong><br/><span class="muted small">${details.join(' · ')}`;
    if (deal.url) {
      infoHtml += ` · <a href="${deal.url}" target="_blank" rel="noopener">Open</a>`;
    }
    infoHtml += '</span>';
    label.innerHTML = infoHtml;

    if (contactsStatus !== 'complete' && contactsStatus !== 'unknown') {
      const badge = document.createElement('span');
      badge.className = 'deal-badge';
      badge.textContent = 'Contacts incomplete';
      label.appendChild(badge);
    }

    item.appendChild(label);
    dealList.appendChild(item);
  });

  dealCard.classList.remove('hidden');
  if (dealMessage) {
    dealMessage.textContent = 'Tick the checkbox next to a deal to populate the metadata preview.';
  }
  if (metadataButton) {
    metadataButton.disabled = true;
  }

  if (sorted.length) {
    setSelectedDeal(0, { renderPreview: true });
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = false;
    }
  } else if (metadataPreviewButton) {
    metadataPreviewButton.disabled = true;
  }
  updateDealButtonState();
}

function handleDealCheckboxChange(event, index) {
  const checkbox = event.target;
  if (!checkbox) return;

  const inputs = dealList
    ? Array.from(dealList.querySelectorAll('input[data-deal-index]'))
    : [];

  if (checkbox.checked) {
    inputs.forEach((input) => {
      const match = Number(input.dataset.dealIndex) === index;
      input.checked = match;
      if (input.parentElement) {
        input.parentElement.classList.toggle('highlight', match);
      }
    });
    setSelectedDeal(index, { updateInputs: false });
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = false;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    updateDealButtonState();
    return;
  }

  const anyChecked = inputs.some((input) => input.checked);
  if (!anyChecked) {
    setSelectedDeal(null);
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
  }
  updateDealButtonState();
}

function setSelectedDeal(index, options = {}) {
  const renderPreview = options.renderPreview === true;
  const updateInputs = options.updateInputs !== false;

  const inputs = dealList
    ? Array.from(dealList.querySelectorAll('input[data-deal-index]'))
    : [];

  if (
    index === null
    || index === undefined
    || !Array.isArray(currentDealList)
    || !currentDealList[index]
  ) {
    currentSelectedDeal = null;
    if (updateInputs) {
      inputs.forEach((input) => {
        input.checked = false;
        if (input.parentElement) {
          input.parentElement.classList.remove('highlight');
        }
      });
    }
    if (dealMessage) {
      dealMessage.textContent = inputs.length
        ? 'Tick the checkbox next to a deal to load metadata values.'
        : 'No associated deals found.';
    }
    if (metadataPreviewButton) {
      metadataPreviewButton.disabled = true;
    }
    if (metadataButton) {
      metadataButton.disabled = true;
    }
    if (metadataPreview) metadataPreview.classList.add('hidden');
    if (metadataPreviewContent) metadataPreviewContent.textContent = '';
    clearSummaryCard();
    updateDealButtonState();
    return;
  }

  currentSelectedDeal = currentDealList[index];

  if (metadataPreview) metadataPreview.classList.add('hidden');
  if (metadataPreviewContent) metadataPreviewContent.textContent = '';

  if (updateInputs) {
    inputs.forEach((input) => {
      const isMatch = Number(input.dataset.dealIndex) === index;
      input.checked = isMatch;
      if (input.parentElement) {
        input.parentElement.classList.toggle('highlight', isMatch);
      }
    });
  }

  if (shouldAutoLoadSubfolders) {
    loadSubfolders({ folderId: presetFolderId, auto: true });
  }

  const props = currentSelectedDeal.properties || {};
  const displayId = props.hs_deal_record_id || currentSelectedDeal.id || '';
  const name = props.dealname || `Deal ${displayId || currentSelectedDeal.id}`;
  const stage = props.dealstage || 'Unknown stage';
  const agreementTs =
    parseTimestamp(props.agreement_start_date) || extractDealTimestamp(currentSelectedDeal);
  const agreementDisplay = formatDate(agreementTs);
  if (dealMessage) {
    dealMessage.textContent = `Using ${name} · Stage: ${stage} · Agreement: ${agreementDisplay}`;
  }
  if (metadataStatus) {
    metadataStatus.textContent = `Deal selected: ${name}. Click Preview Metadata to review before applying.`;
  }
  if (renderPreview) {
    generateMetadataPreview();
  }
  updateDealButtonState();
}

  function updateFolderSummary() {
    if (!folderSummary) {
      return;
    }
    const name = currentFolderInfo?.name || '';
    const url = currentFolderInfo?.url || '';
    if (!name) {
      folderSummary.textContent = '';
      folderSummary.innerHTML = '';
      folderSummary.title = '';
      return;
    }
    folderSummary.title = name;
    if (url) {
      folderSummary.innerHTML = `Folder: <a href="${url}" target="_blank" rel="noopener">${name}</a>`;
    } else {
      folderSummary.textContent = `Folder: ${name}`;
    }
  }

  function generateMetadataPreview(existingPayload, selectedDealOverride) {
    const payload = existingPayload || buildPayloadFromSelectedDeal(selectedDealOverride);
    if (!payload) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Metadata preview unavailable. Select a deal and ensure a folder id is set.';
      }
      clearSummaryCard();
      return;
    }
    const previewData = buildMetadataPreview(payload, selectedDealOverride || currentSelectedDeal, lastContactData?.contact);
    if (metadataPreviewContent) {
      metadataPreviewContent.textContent = JSON.stringify(previewData, null, 2);
    }
    if (metadataPreview) {
      metadataPreview.classList.remove('hidden');
    }
    if (metadataStatus) {
      metadataStatus.textContent = 'Metadata preview generated. Review before applying.';
    }
    if (statusText) {
      statusText.textContent = 'Metadata preview generated.';
    }
    if (metadataButton) {
      metadataButton.disabled = false;
    }
    updateSummaryCard(previewData);
    return previewData;
  }

  function buildPayloadFromSelectedDeal(selectedDealOverride) {
    const folderValue = rootFolderId
      || (lastCollabResponse && lastCollabResponse.folder_id)
      || (lastCollabResponse && lastCollabResponse.inspected && lastCollabResponse.inspected.id)
      || currentFolderId
      || folderInput.value.trim();
    const folderId = normalizeFolderId(folderValue);
    if (!folderId) {
      return null;
    }

    const deal = selectedDealOverride || currentSelectedDeal;
    const dealProps = (deal && deal.properties) || {};
    const dealId = String(dealProps.hs_deal_record_id || deal?.id || '').trim();
    if (!dealId) {
      return null;
    }

    const payload = {
      folder_id: folderId,
      deal_id: dealId,
      hs_deal_record_id: dealId,
    };

    if (lastContactData && lastContactData.contact) {
      const contact = lastContactData.contact;
      const props = contact.properties || {};
      if (contact.id) payload.hs_contact_id = contact.id;
      if (props.firstname) payload.hs_contact_firstname = props.firstname;
      if (props.lastname) payload.hs_contact_lastname = props.lastname;
      if (props.email) payload.hs_contact_email = props.email;
    }

    if (dealProps) {
      if (dealProps.deal_salutation) payload.deal_salutation = dealProps.deal_salutation;
      if (dealProps.household_type) payload.household_type = dealProps.household_type;
      if (dealProps.hs_spouse_id) payload.hs_spouse_id = dealProps.hs_spouse_id;
      if (dealProps.hs_spouse_firstname) payload.hs_spouse_firstname = dealProps.hs_spouse_firstname;
      if (dealProps.hs_spouse_lastname) payload.hs_spouse_lastname = dealProps.hs_spouse_lastname;
      if (dealProps.hs_spouse_email) payload.hs_spouse_email = dealProps.hs_spouse_email;
    }

    return payload;
  }

  function resolveDealUpdateInputs(selectedDealOverride) {
    if (!metadataDealButton || !dealPropertyName) {
      return null;
    }
    const payload = buildPayloadFromSelectedDeal(selectedDealOverride);
    if (!payload) {
      return null;
    }
    const folderId = normalizeFolderId(payload.folder_id);
    const dealId = String(payload.deal_id || payload.hs_deal_record_id || '').trim();
    if (!folderId || !dealId) {
      return null;
    }
    return {
      folderId,
      dealId,
      payload,
      deal: selectedDealOverride || currentSelectedDeal,
    };
  }

  function canUpdateDealBoxUrl() {
    return Boolean(resolveDealUpdateInputs());
  }

  function updateDealButtonState() {
    if (!metadataDealButton) {
      return;
    }
    if (!dealPropertyName) {
      metadataDealButton.disabled = true;
      metadataDealButton.title = 'Configure HUBSPOT_BOX_FOLDER_DEAL_PROPERTY to enable deal updates.';
      return;
    }
    metadataDealButton.disabled = !canUpdateDealBoxUrl();
    if (!metadataDealButton.disabled) {
      metadataDealButton.title = '';
    }
  }

  async function updateDealBoxFolder() {
    if (!metadataDealButton) {
      return;
    }
    if (!dealPropertyName) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Configure HUBSPOT_BOX_FOLDER_DEAL_PROPERTY to enable deal updates.';
      }
      return;
    }

    const resolved = resolveDealUpdateInputs();
    if (!resolved) {
      if (metadataStatus) {
        metadataStatus.textContent = 'Select a deal and ensure the folder id is loaded before updating the deal property.';
      }
      updateDealButtonState();
      return;
    }

    const { folderId, dealId, deal } = resolved;
    const properties = (deal && deal.properties) || {};
    const dealName = properties.dealname || `Deal ${dealId}`;

    if (metadataStatus) {
      metadataStatus.textContent = `Updating HubSpot deal ${dealName} with Box folder URL…`;
    }
    if (statusText) {
      statusText.textContent = 'Updating HubSpot deal with Box folder URL…';
    }
    setBusy(metadataDealButton, true, 'Updating…');

    try {
      const payload = {
        folder_id: folderId,
        deal_id: dealId,
        hs_deal_record_id: dealId,
      };
      const data = await fetchJSON('/box/folder/deal-box-url', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });
      if (metadataStatus) {
        const propertyLabel = dealPropertyName || 'box folder URL';
        metadataStatus.textContent = `HubSpot deal ${data.deal_id} updated (${propertyLabel}).`;
      }
      if (statusText) {
        statusText.textContent = `Success · Deal ${data.deal_id} updated with ${data.box_folder_url}`;
      }
    } catch (error) {
      if (metadataStatus) {
        metadataStatus.textContent = `Deal property update failed: ${error.message}`;
      }
      if (statusText) {
        statusText.textContent = `Deal update failed · ${error.message}`;
      }
      console.error('Deal box URL update failed:', error);
    } finally {
      setBusy(metadataDealButton, false);
      updateDealButtonState();
    }
  }

  resetUI();
  if (presetFolderId) {
    autoStartForPresetFolder();
  }
</script>
{% endblock %}

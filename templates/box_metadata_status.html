{% extends "layout.html" %}
{% set title = "Box Metadata Snapshot" %}

{% block content %}
<div class="topbar">
  <div style="display:flex;align-items:center;gap:16px;">
    <a href="/box/collaborators" style="color:#d0d7e2;text-decoration:none;font-size:0.9em;">‚Üê Box Tools</a>
    <h2>Box Metadata Snapshot</h2>
  </div>
  <div class="topbar-right">
    <a class="guide-link" href="/box/folder/metadata/guide" target="_blank" rel="noopener">
      Tagging Guide
    </a>
    <div class="datebox">
      <span>Today: {{ today }}</span>
      <span>Updated: {{ updated_at_display or "Not cached yet" }}</span>
      <span>
        Cached:
        {% if preview_cache_summary.total %}
          {{ preview_cache_summary.success or preview_cache_summary.total }}/{{ preview_cache_summary.total }}
        {% else %}
          0/0
        {% endif %}
      </span>
    </div>
  </div>
</div>

<div class="card search-panel">
  <label for="folder-search" class="search-label">Search folders</label>
  <input
    id="folder-search"
    class="search-input"
    type="search"
    placeholder="Search by folder name, ID, or path‚Ä¶"
    autocomplete="off"
    spellcheck="false"
  />
  <p class="muted small">Filters folders across all sections instantly.</p>
  <p id="search-results-note" class="muted small"></p>
</div>

{% if error_message %}
<div class="card">
  <h3>Snapshot unavailable</h3>
  <p class="muted">{{ error_message }}</p>
  <p class="muted small">Enable Firestore or check service access to view the cached metadata status.</p>
</div>
{% else %}
<div class="card summary-card">
  <div class="summary-grid">
    <div class="summary-tile tagged">
      <span class="label">Tagged</span>
      <span class="metric">{{ counts.tagged }}</span>
    </div>
    <div class="summary-tile untagged">
      <span class="label">Untagged</span>
      <span class="metric">{{ counts.untagged }}</span>
    </div>
    <div class="summary-tile issues">
      <span class="label">Issues</span>
      <span class="metric">{{ counts.issues }}</span>
    </div>
    <div class="summary-tile mismatch">
      <span class="label">Mismatch queue</span>
      <span class="metric">{{ counts.mismatch or 0 }}</span>
    </div>
  </div>
  <p class="muted small">
    Snapshot stored in Firestore at <code>box_folder_metadata/tagging_status</code>.
  </p>
</div>

{% if assignment_slots %}
<details class="card collapsible assignment-card" open>
  <summary>Assignment queues ({{ assignment_slots|length }})</summary>
  <p class="muted small">
    Slots computed from <code>folder_id % {{ assignment_slots|length }}</code> so every refresh keeps the same owner.
    Provide your own labels using <code>?assignees=Alex,Bianca,...</code>.
  </p>
  <div class="assignment-grid">
    {% for slot in assignment_slots %}
    <details class="assignment-slot">
      <summary>
        <span class="slot-name">{{ slot.assignee }}</span>
        <span class="slot-count">
          {{ slot.count }} folders
          {% if slot.cached_count %}
          <span class="slot-cached">{{ slot.cached_count }} cached</span>
          {% endif %}
        </span>
      </summary>
      {% if slot.folders %}
      <ul class="folder-list compact">
        {% for folder in slot.folders %}
        <li{% if folder.preview_generated_at %} class="cached-folder"{% endif %}
          data-folder-name="{{ display_name|e }}"
          data-folder-id="{{ (folder.id or '')|e }}"
          data-folder-path="{{ (folder.path or '')|e }}"
        >
          <div class="folder-meta">
            {% set display_name = folder.name or folder.id %}
            <span class="folder-name">{{ display_name }}</span>
            {% if folder.id and folder.id != display_name %}
            <span class="folder-id"><code>{{ folder.id }}</code></span>
            {% endif %}
            {% if folder.path %}
            <span class="folder-path muted small">{{ folder.path }}</span>
            {% endif %}
            {% set preview_checked = folder.preview_generated_at_display or folder.preview_generated_at %}
            {% if preview_checked %}
            <span class="folder-tagged muted small cached-pill">Cached preview ¬∑ {{ preview_checked }}</span>
            {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <div class="preview-actions">
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
        <button
          type="button"
          class="secondary danger mismatch-link hidden"
          data-folder-id="{{ folder.id }}"
          data-default="Move to mismatch queue"
        >
          Move to mismatch queue
        </button>
        </div>
      </div>
    </li>
    {% endfor %}
  </ul>
      {% else %}
      <p class="muted small">No folders currently allocated to this slot.</p>
      {% endif %}
    </details>
    {% endfor %}
  </div>
</details>
{% endif %}

<details class="card collapsible" {% if counts.untagged and counts.untagged <= 40 %}open{% endif %}>
  <summary>Untagged folders ({{ counts.untagged }})</summary>
  {% if not snapshot_exists %}
  <p class="muted">No metadata snapshot has been captured yet. Refresh to load the latest folder status.</p>
  {% elif untagged_entries %}
  <p class="muted">These folders still need the metadata template applied.</p>
  <ul class="folder-list">
    {% for folder in untagged_entries %}
    <li
      data-folder-name="{{ display_name|e }}"
      data-folder-id="{{ (folder.id or '')|e }}"
      data-folder-path="{{ (folder.path or '')|e }}"
    >
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <div class="preview-actions">
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
        <button
          type="button"
          class="secondary danger mismatch-link hidden"
          data-folder-id="{{ folder.id }}"
          data-default="Move to mismatch queue"
        >
          Move to mismatch queue
        </button>
        </div>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted">All tracked folders currently have metadata applied.</p>
  {% endif %}
</details>

<details class="card collapsible">
  <summary>Folders without associated deals ({{ untagged_no_deal_entries|length }})</summary>
  <div class="card-toolbar no-deal-toolbar">
    <button type="button" class="secondary" id="no-deal-retry-btn" data-default="Re-run checks">
      Re-run checks
    </button>
    <span id="no-deal-retry-status" class="muted small"></span>
  </div>
  <p class="muted small">
    Cached metadata previews could not locate a HubSpot deal for these folders.
    Re-run the preview or investigate the contact/deal in HubSpot before tagging.
  </p>
  {% if untagged_no_deal_entries %}
  <ul class="folder-list">
    {% for folder in untagged_no_deal_entries %}
    <li
      data-folder-name="{{ display_name|e }}"
      data-folder-id="{{ (folder.id or '')|e }}"
      data-folder-path="{{ (folder.path or '')|e }}"
    >
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
        {% set preview_checked = folder.preview_generated_at_display or folder.preview_generated_at %}
        {% if preview_checked %}
        <span class="folder-tagged muted small">Preview checked {{ preview_checked }}</span>
        {% endif %}
        {% if folder.preview_error %}
        <span class="muted small" style="color:#b91c1c;">{{ folder.preview_error }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted small">No folders currently flagged as missing HubSpot deals.</p>
  {% endif %}
</details>

<details class="card collapsible" {% if mismatch_entries %}open{% endif %}>
  <summary>Mismatch queue ({{ mismatch_entries|length }})</summary>
  <p class="muted small">
    These folders were skipped because the suggested HubSpot data didn‚Äôt match. Review them manually.
  </p>
  {% if mismatch_entries %}
  <ul class="folder-list">
    {% for folder in mismatch_entries %}
    <li
      data-folder-name="{{ folder.name|e }}"
      data-folder-id="{{ (folder.id or '')|e }}"
      data-folder-path="{{ (folder.path or '')|e }}"
    >
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
        {% if folder.mismatch_reason %}
        <span class="folder-tagged muted small" style="color:#b45309;">Reason: {{ folder.mismatch_reason }}</span>
        {% endif %}
        {% if folder.preview_generated_at %}
        <span class="folder-tagged muted small">Last preview {{ folder.preview_generated_at }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <div class="preview-actions">
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
        <button
          type="button"
          class="secondary danger mismatch-link hidden"
          data-folder-id="{{ folder.id }}"
          data-default="Move to mismatch queue"
        >
          Move to mismatch queue
        </button>
        </div>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted small">Great! No folders are waiting in the mismatch queue.</p>
  {% endif %}
</details>

<details class="card collapsible" {% if counts.tagged and counts.tagged <= 40 %}open{% endif %}>
  <summary>Tagged folders ({{ counts.tagged }})</summary>
  {% if not snapshot_exists %}
  <p class="muted">No folders captured yet. Refresh the snapshot to record the current state.</p>
  {% elif tagged_entries %}
  <ul class="folder-list compact">
    {% for folder in tagged_entries %}
    <li
      data-folder-name="{{ display_name|e }}"
      data-folder-id="{{ (folder.id or '')|e }}"
      data-folder-path="{{ (folder.path or '')|e }}"
    >
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
        {% set tagged_stamp = folder.tagged_at_display or folder.tagged_at %}
        {% if tagged_stamp %}
        <span class="folder-tagged muted small">Tagged at {{ tagged_stamp }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <div class="preview-actions">
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
        <button
          type="button"
          class="secondary danger mismatch-link hidden"
          data-folder-id="{{ folder.id }}"
          data-default="Move to mismatch queue"
        >
          Move to mismatch queue
        </button>
        </div>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted">No tagged folders recorded in the snapshot yet.</p>
  {% endif %}
</details>

{% if issues %}
<div class="card warning-card">
  <h3>Scan issues</h3>
  <p class="muted small">The following folders could not be inspected during the last scan:</p>
  <ul class="issue-list">
    {% for issue in issues %}
    <li>{{ issue }}</li>
    {% endfor %}
  </ul>
</div>
{% endif %}
{% endif %}
{% if allow_refresh %}
<div class="refresh-footer">
  <button id="refresh-btn" class="secondary refresh-btn" data-default="Refresh snapshot">
    Refresh snapshot
  </button>
  <button
    id="preview-cache-btn"
    class="secondary refresh-btn"
    data-default="Run metadata preview cache"
  >
    Run metadata preview cache
  </button>
  <button
    id="box-scan-btn"
    class="secondary refresh-btn"
    data-default="Scan Box for new folders"
  >
    Scan Box for new folders
  </button>
  {% if preview_cache_summary.total %}
  <span class="muted small">
    Cached {{ preview_cache_summary.success or preview_cache_summary.total }}/{{ preview_cache_summary.total }} ¬∑
    Updated {{ preview_cache_summary.updated_at or "n/a" }}
  </span>
  {% endif %}
  <span id="preview-cache-status" class="muted small"></span>
  <span id="refresh-status" class="muted small"></span>
  <span id="box-scan-status" class="muted small"></span>
  <span id="no-deal-footer-status" class="muted small"></span>
</div>
{% endif %}
{% endblock %}

{% block head %}
<style>
  .summary-card {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .search-panel {
    margin: 16px 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .search-label {
    font-weight: 600;
  }

  .search-input {
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 0.95em;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
  }

  .search-input:focus {
    outline: none;
    border-color: #6366f1;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
  }

  .search-hidden {
    display: none !important;
  }

  .err {
    color: #b91c1c !important;
  }

  #search-results-note {
    margin: 0;
  }

  #search-results-note:empty {
    display: none;
  }

  .search-filter-empty summary {
    color: #94a3b8;
  }

  .search-filter-empty {
    opacity: 0.6;
  }

  .card-toolbar {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .no-deal-toolbar {
    justify-content: flex-end;
  }

  .topbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .guide-link {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9em;
    font-weight: 600;
    padding: 8px 14px;
    border-radius: 999px;
    background: linear-gradient(135deg, #6366f1, #4338ca);
    color: #ffffff;
    text-decoration: none;
    box-shadow: 0 6px 18px rgba(99, 102, 241, 0.35);
    transition: transform 0.1s ease, box-shadow 0.1s ease;
  }

  .guide-link::before {
    content: "üìò";
    font-size: 1.05em;
  }

  .guide-link:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 24px rgba(67, 56, 202, 0.45);
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
  }

  .summary-tile {
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    background: rgba(15, 23, 42, 0.03);
  }

  .summary-tile .label {
    display: block;
    font-size: 0.85em;
    color: var(--muted);
    margin-bottom: 4px;
  }

  .summary-tile .metric {
    font-size: 1.8em;
    font-weight: 600;
  }

  .summary-tile.tagged {
    border-color: rgba(34, 197, 94, 0.35);
    background: rgba(34, 197, 94, 0.08);
  }

  .summary-tile.untagged {
    border-color: rgba(239, 68, 68, 0.25);
    background: rgba(239, 68, 68, 0.08);
  }

  .summary-tile.issues {
    border-color: rgba(249, 115, 22, 0.3);
    background: rgba(249, 115, 22, 0.1);
  }

  .summary-tile.mismatch {
    border-color: rgba(245, 158, 11, 0.4);
    background: rgba(253, 230, 138, 0.2);
  }

  .folder-list {
    list-style: none;
    padding: 0;
    margin: 12px 0 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .folder-list li {
    display: flex;
    align-items: center;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    background: #fff;
    gap: 12px;
    justify-content: space-between;
  }

  .folder-list.compact {
    flex-direction: column;
  }

  .folder-list.compact li {
    justify-content: space-between;
  }

  .folder-list code {
    font-size: 0.9em;
  }

  .folder-meta {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-width: 75%;
  }

  .folder-name {
    font-weight: 600;
  }

  .folder-path {
    word-break: break-word;
  }

  .folder-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
  }

  .folder-list a {
    font-size: 0.85em;
    color: var(--brand);
  }

  .assignment-card {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .assignment-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .assignment-slot {
    border: 1px solid var(--border);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.03);
    padding: 12px;
  }

  .assignment-slot[open] {
    background: rgba(15, 23, 42, 0.05);
  }

  .assignment-slot summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .assignment-slot summary::-webkit-details-marker {
    display: none;
  }

  .slot-count {
    font-size: 0.85em;
    color: var(--muted);
  }

  .slot-cached {
    margin-left: 6px;
    color: #4c1d95;
    font-weight: 600;
    font-size: 0.75em;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .assignment-slot .folder-list {
    margin-top: 8px;
  }

  .folder-list li.cached-folder {
    border-color: rgba(99, 102, 241, 0.45);
    background: rgba(99, 102, 241, 0.08);
    box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.08);
  }

  .cached-pill {
    color: #4338ca;
    font-weight: 600;
  }

  .refresh-footer {
    margin-top: 24px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .refresh-btn {
    padding: 6px 10px;
    font-size: 0.85em;
    color: #4b5563;
    border-color: #d1d5db;
    background: #f3f4f6;
  }

  .refresh-btn:hover {
    background: #e5e7eb;
    border-color: #cbd5f5;
  }

  .hidden {
    display: none !important;
  }

  .folder-preview {
    margin-top: 12px;
    padding: 12px 14px;
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(241, 245, 249, 0.5);
    display: grid;
    gap: 10px;
  }

  .preview-status {
    margin: 0;
    color: #475569;
  }

  .preview-status.error {
    color: #b91c1c;
    font-weight: 600;
  }

  .preview-summary {
    background: #ffffff;
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.4);
    padding: 12px 14px;
    box-shadow: 0 10px 22px rgba(15, 23, 42, 0.08);
  }

  .preview-summary h4 {
    margin: 0 0 6px;
    font-size: 0.95rem;
    color: #1f2937;
  }

  .preview-summary p {
    margin: 2px 0;
    font-size: 0.9rem;
    color: #334155;
  }

  .preview-summary p span {
    display: inline-block;
    margin-left: 6px;
  }

  .preview-summary a {
    color: #2563eb;
  }

  .preview-metadata table {
    width: 100%;
    border-collapse: collapse;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.35);
    background: #fff;
  }

  .preview-metadata th,
  .preview-metadata td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.25);
    text-align: left;
    font-size: 0.88rem;
  }

  .preview-metadata th {
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    color: #475569;
    background: rgba(241, 245, 249, 0.7);
  }

  .preview-metadata td pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 0.82rem;
  }

  .preview-pipeline {
    border-left: 3px solid rgba(99, 102, 241, 0.55);
    padding-left: 12px;
    display: grid;
    gap: 4px;
  }

  .preview-pipeline span {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .preview-pipeline .status-info::before {
    content: "‚Ä¢";
    color: #4338ca;
  }

  .preview-pipeline .status-success::before {
    content: "‚Ä¢";
    color: #0f766e;
  }

  .preview-pipeline .status-error::before {
    content: "‚Ä¢";
    color: #b91c1c;
  }

  .folder-preview .apply-link {
    justify-self: start;
  }

  .preview-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .danger {
    background: #fee2e2;
    border: 1px solid #f87171;
    color: #b91c1c;
  }

  .danger:hover {
    background: #fecaca;
    border-color: #ef4444;
  }
  .warning-card {
    border: 1px solid rgba(249, 115, 22, 0.4);
    background: rgba(249, 115, 22, 0.12);
  }

  .issue-list {
    margin: 8px 0 0;
    padding-left: 1.2rem;
  }

  details.collapsible summary {
    cursor: pointer;
    font-weight: 600;
    margin-bottom: 8px;
  }

  details.collapsible[open] summary {
    margin-bottom: 12px;
  }

</style>
{% endblock %}

{% block scripts %}
<script>
  const refreshBtn = document.getElementById("refresh-btn");
  const previewCacheBtn = document.getElementById("preview-cache-btn");
  const boxScanBtn = document.getElementById("box-scan-btn");
  const noDealRetryBtn = document.getElementById("no-deal-retry-btn");
  const status = document.getElementById("refresh-status");
  const previewCacheStatus = document.getElementById("preview-cache-status");
  const boxScanStatus = document.getElementById("box-scan-status");
  const noDealRetryStatus = document.getElementById("no-deal-retry-status");
  const noDealFooterStatus = document.getElementById("no-deal-footer-status");
  const folderSearchInput = document.getElementById("folder-search");
  const searchResultsNote = document.getElementById("search-results-note");

  async function runRefreshSnapshot() {
    if (!refreshBtn || !status) return;
    status.textContent = "";
    status.classList.remove("err");
    const defaultLabel = refreshBtn.dataset.default || "Refresh snapshot";
    refreshBtn.disabled = true;
    refreshBtn.textContent = "Refreshing‚Ä¶";
    console.log("[BoxMetadata] Refresh snapshot triggered");
    try {
      const response = await fetch("/box/folder/metadata/cache", { method: "POST" });
      if (!response.ok) {
        let detail = "";
        try {
          const payload = await response.json();
          detail = payload.message || payload.error || "";
        } catch (_) {
          detail = "";
        }
        throw new Error(detail || response.statusText);
      }
      refreshBtn.textContent = "Reloading‚Ä¶";
      status.textContent = "Snapshot refreshed. Reloading‚Ä¶";
      window.setTimeout(() => window.location.reload(), 600);
    } catch (error) {
      refreshBtn.disabled = false;
      refreshBtn.textContent = defaultLabel;
      status.textContent = `Failed to refresh: ${error.message}`;
      status.classList.add("err");
    }
  }

  async function runPreviewCache() {
    if (!previewCacheBtn || !previewCacheStatus) return;
    previewCacheStatus.textContent = "";
    previewCacheStatus.classList.remove("err");
    const defaultLabel = previewCacheBtn.dataset.default || "Run metadata preview cache";
    previewCacheBtn.disabled = true;
    previewCacheBtn.textContent = "Running‚Ä¶";
    console.log("[BoxMetadata] Preview cache triggered");
    try {
      const response = await fetch("/box/folder/metadata/previews/run", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({}),
      });
      if (!response.ok) {
        let detail = "";
        try {
          const payload = await response.json();
          detail = payload.message || payload.error || "";
        } catch (_) {
          detail = "";
        }
        throw new Error(detail || response.statusText);
      }
      const payload = await response.json();
      const summaryParts = [];
      summaryParts.push(`Processed ${payload.processed} folder(s)`);
      if (payload.skipped) {
        summaryParts.push(`Skipped ${payload.skipped}`);
      }
      if (payload.errors && payload.errors.length) {
        summaryParts.push(`Errors ${payload.errors.length}`);
      }
      previewCacheStatus.textContent = `${summaryParts.join(" ¬∑ ")}. Refresh snapshot when ready.`;
      previewCacheStatus.classList.remove("err");
    } catch (error) {
      previewCacheStatus.textContent = `Preview cache failed: ${error.message}`;
      previewCacheStatus.classList.add("err");
    } finally {
      previewCacheBtn.disabled = false;
      previewCacheBtn.textContent = defaultLabel;
    }
  }

  async function runBoxScan() {
    if (!boxScanBtn || !boxScanStatus) return;
    boxScanStatus.textContent = "";
    boxScanStatus.classList.remove("err");
    const defaultLabel = boxScanBtn.dataset.default || "Scan Box for new folders";
    boxScanBtn.disabled = true;
    boxScanBtn.textContent = "Scanning‚Ä¶";
    console.log("[BoxMetadata] Box folder scan triggered");
    try {
      const response = await fetch("/box/folder/metadata/scan", { method: "POST" });
      if (!response.ok) {
        let detail = "";
        try {
          const payload = await response.json();
          detail = payload.message || payload.error || "";
        } catch (_) {
          detail = "";
        }
        throw new Error(detail || response.statusText);
      }
      const payload = await response.json();
      const parts = [];
      parts.push(`New tagged: ${payload.new_tagged || 0}`);
      parts.push(`New untagged: ${payload.new_untagged || 0}`);
      if (payload.preview_cached !== undefined) {
        parts.push(`Previews cached: ${payload.preview_cached}`);
      }
      if (payload.preview_errors) {
        parts.push(`Preview errors: ${payload.preview_errors}`);
      }
      if (payload.unauthorized) {
        parts.push(`401s: ${payload.unauthorized}`);
      }
      boxScanStatus.textContent = `${parts.join(" ¬∑ ")}. Refresh snapshot to view them.`;
      boxScanStatus.classList.remove("err");
    } catch (error) {
      boxScanStatus.textContent = `Scan failed: ${error.message}`;
      boxScanStatus.classList.add("err");
    } finally {
      boxScanBtn.disabled = false;
      boxScanBtn.textContent = defaultLabel;
    }
  }

  async function runNoDealRetry() {
    if (!noDealRetryBtn || !noDealRetryStatus) return;
    noDealRetryStatus.textContent = "";
    noDealRetryStatus.classList.remove("err");
    if (noDealFooterStatus) {
      noDealFooterStatus.textContent = "";
      noDealFooterStatus.classList.remove("err");
    }
    const defaultLabel = noDealRetryBtn.dataset.default || "Re-run checks";
    noDealRetryBtn.disabled = true;
    noDealRetryBtn.textContent = "Running‚Ä¶";
    console.log("[BoxMetadata] No-deal retry triggered");
    try {
      const response = await fetch("/box/folder/metadata/no-deal/retry", { method: "POST" });
      if (!response.ok) {
        let detail = "";
        try {
          const payload = await response.json();
          detail = payload.message || payload.error || "";
        } catch (_) {
          detail = "";
        }
        throw new Error(detail || response.statusText);
      }
      const payload = await response.json();
      const parts = [];
      parts.push(`Processed ${payload.processed || 0}`);
      parts.push(`Moved out of no-deal ${payload.resolved || 0}`);
      parts.push(`Still in no-deal ${payload.remaining || 0}`);
      if (payload.unauthorized) {
        parts.push(`401s ${payload.unauthorized}`);
      }
      const summary = `${parts.join(" ¬∑ ")}. Refresh snapshot to view updates.`;
      noDealRetryStatus.textContent = summary;
      noDealRetryStatus.classList.remove("err");
      if (noDealFooterStatus) {
        noDealFooterStatus.textContent = summary;
        noDealFooterStatus.classList.remove("err");
      }
    } catch (error) {
      noDealRetryStatus.textContent = `Retry failed: ${error.message}`;
      noDealRetryStatus.classList.add("err");
      if (noDealFooterStatus) {
        noDealFooterStatus.textContent = `Retry failed: ${error.message}`;
        noDealFooterStatus.classList.add("err");
      }
    } finally {
      noDealRetryBtn.disabled = false;
      noDealRetryBtn.textContent = defaultLabel;
    }
  }

  if (refreshBtn) {
    refreshBtn.addEventListener("click", runRefreshSnapshot);
  }
  if (previewCacheBtn) {
    previewCacheBtn.addEventListener("click", runPreviewCache);
  }
  if (boxScanBtn) {
    boxScanBtn.addEventListener("click", runBoxScan);
  }
  if (noDealRetryBtn) {
    noDealRetryBtn.addEventListener("click", runNoDealRetry);
  }
  document.querySelectorAll(".mismatch-link").forEach((button) => {
    button.addEventListener("click", async () => {
      const folderId = button.dataset.folderId;
      if (!folderId) return;
      const reasonInput = window.prompt("Describe the mismatch (optional):", "");
      button.disabled = true;
      button.textContent = "Moving‚Ä¶";
      try {
        const response = await fetch("/box/folder/metadata/mismatch", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ folder_id: folderId, reason: reasonInput || "" }),
        });
        if (!response.ok) {
          const detail = await response.json().catch(() => ({}));
          throw new Error(detail.message || response.statusText);
        }
        const payload = await response.json();
        const message = payload.message || "Folder moved to mismatch queue.";
        setPreviewStatus(folderId, `${message} Refresh snapshot to update lists.`);
      } catch (error) {
        setPreviewStatus(folderId, `Mismatch move failed ¬∑ ${error.message}`, true);
      } finally {
        button.disabled = false;
        button.textContent = button.dataset.default || "Move to mismatch queue";
      }
    });
  });
  if (folderSearchInput) {
    folderSearchInput.addEventListener("input", () => {
      applyFolderSearch(folderSearchInput.value || "");
    });
  }
  document.querySelectorAll(".collab-link").forEach((button) => {
    button.addEventListener("click", () => {
      const folderId = button.dataset.folderId;
      if (!folderId) {
        return;
      }
      const url = `/box/collaborators?folder_id=${encodeURIComponent(folderId)}`;
      const win = window.open(url, "_blank");
      if (win) {
        win.opener = null;
      }
    });
  });

  const previewState = new Map();
  const PREVIEW_CACHE_ENABLED = {{ "true" if preview_cache_enabled else "false" }};
  const previewContainers = new Map();
  const PIVOT_DOMAIN = "@pivotwealth.com.au";
  const previewCacheInitial = {{ preview_cache_summary | tojson }};
  if (previewCacheStatus && previewCacheInitial && previewCacheInitial.total) {
    const initParts = [];
    initParts.push(
      `Cached ${previewCacheInitial.success ?? previewCacheInitial.total}/${previewCacheInitial.total}`,
    );
    if (previewCacheInitial.updated_at) {
      initParts.push(`Updated ${previewCacheInitial.updated_at}`);
    }
    previewCacheStatus.textContent = initParts.join(" ¬∑ ");
  }

  function setBusy(button, busy, label) {
    if (!button) return;
    if (busy) {
      button.dataset.default = button.dataset.default || button.textContent;
      button.textContent = label || "Working‚Ä¶";
      button.disabled = true;
    } else {
      button.textContent = button.dataset.default || button.textContent;
      button.disabled = false;
    }
  }

  async function fetchJSON(url, options) {
    let response;
    try {
      response = await fetch(url, options);
    } catch (error) {
      throw new Error(`Network error: ${error.message}`);
    }
    const contentType = response.headers.get("content-type") || "";
    const isJSON = contentType.includes("application/json");
    let data = null;
    if (isJSON) {
      try {
        data = await response.json();
      } catch (error) {
        throw new Error("Invalid JSON response received");
      }
    } else {
      const text = await response.text();
      data = text ? { raw: text } : null;
    }
    if (!response.ok) {
      const message = (data && (data.message || data.error)) || response.statusText;
      const error = new Error(message);
      if (data && data.detail) {
        error.detail = data.detail;
      }
      throw error;
    }
    return data;
  }

  function escapeHtml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function escapeAttr(value) {
    return String(value ?? "").replace(/"/g, '\\"');
  }

  function buildFolderHaystack(item) {
    if (!item) return "";
    if (item.dataset.searchHaystack) {
      return item.dataset.searchHaystack;
    }
    const parts = [
      item.dataset.folderName || "",
      item.dataset.folderId || "",
      item.dataset.folderPath || "",
    ]
      .join(" ")
      .trim();
    let haystack = parts.toLowerCase();
    if (!haystack) {
      const meta = item.querySelector(".folder-meta");
      haystack = (meta && meta.textContent ? meta.textContent : item.textContent || "").toLowerCase();
    }
    item.dataset.searchHaystack = haystack;
    return haystack;
  }

  function updateSectionSearchState(hasQuery) {
    const sections = document.querySelectorAll("details.assignment-slot, details.collapsible");
    sections.forEach((section) => {
      const list = section.querySelectorAll(".folder-list li");
      if (!list.length) return;
      const visible = Array.from(list).some((item) => !item.classList.contains("search-hidden"));
      section.classList.toggle("search-filter-empty", Boolean(hasQuery) && !visible);
    });
  }

  function applyFolderSearch(term) {
    const query = (term || "").trim().toLowerCase();
    let matchCount = 0;
    const items = document.querySelectorAll(".folder-list li");
    items.forEach((item) => {
      if (!query) {
        item.classList.remove("search-hidden");
        matchCount += 1;
        return;
      }
      const haystack = buildFolderHaystack(item);
      const matches = haystack.includes(query);
      item.classList.toggle("search-hidden", !matches);
      if (matches) {
        matchCount += 1;
      }
    });
    updateSectionSearchState(query.length > 0);
    if (searchResultsNote) {
      if (!query) {
        searchResultsNote.textContent = "";
      } else if (matchCount === 0) {
        searchResultsNote.textContent = "No folders match your search.";
      } else {
        const plural = matchCount === 1 ? "" : "s";
        searchResultsNote.textContent = `Showing ${matchCount} folder${plural} matching ‚Äú${term.trim()}‚Äù.`;
      }
    }
  }

  async function fetchCachedPreview(folderId, options = {}) {
    const refresh = options.refresh === true;
    const url = new URL("/box/folder/metadata/preview", window.location.origin);
    url.searchParams.set("folder_id", folderId);
    if (refresh) {
      url.searchParams.set("refresh", "1");
    }
    return fetchJSON(url);
  }

  function getPreviewElements(folderId, hintElement) {
    const key = String(folderId ?? "");
    if (!key) {
      return null;
    }
    const attrValue = escapeAttr(key);
    let container = null;
    if (hintElement instanceof Element) {
      if (hintElement.matches(`[data-preview-container]`)) {
        container = hintElement;
      } else {
        const direct = hintElement.closest(`[data-preview-container]`);
        if (direct) {
          container = direct;
        } else {
          const host = hintElement.closest("li");
          if (host) {
            container = host.querySelector(`[data-preview-container="${attrValue}"]`);
          }
        }
      }
    }
    if (!container) {
      container = previewContainers.get(key) || null;
    }
    if (!container) {
      container = document.querySelector(`[data-preview-container="${attrValue}"]`);
    }
    if (!container) return null;
    previewContainers.set(key, container);
    return {
      container,
      status: container.querySelector(`[data-preview-status="${attrValue}"]`),
      summary: container.querySelector(`[data-preview-summary="${attrValue}"]`),
      metadata: container.querySelector(`[data-preview-metadata="${attrValue}"]`),
    pipeline: container.querySelector(`[data-preview-pipeline="${attrValue}"]`),
    applyBtn: container.querySelector(`.apply-link[data-folder-id="${attrValue}"]`),
    mismatchBtn: container.querySelector(`.mismatch-link[data-folder-id="${attrValue}"]`),
  };
}

  function resetPreviewDisplay(folderId, hintElement) {
    const elements = getPreviewElements(folderId, hintElement);
    if (!elements) return;
    if (elements.status) {
      elements.status.textContent = "";
      elements.status.classList.remove("error");
    }
    if (elements.summary) {
      elements.summary.classList.add("hidden");
      elements.summary.innerHTML = "";
    }
    if (elements.metadata) {
      elements.metadata.classList.add("hidden");
      elements.metadata.innerHTML = "";
    }
    if (elements.pipeline) {
      elements.pipeline.classList.add("hidden");
      elements.pipeline.innerHTML = "";
    }
    if (elements.applyBtn) {
      elements.applyBtn.classList.add("hidden");
      elements.applyBtn.disabled = true;
      const label =
        elements.applyBtn.dataset.default || "Apply metadata and Box folder tagging";
      elements.applyBtn.textContent = label;
    }
    if (elements.mismatchBtn) {
      elements.mismatchBtn.classList.add("hidden");
      elements.mismatchBtn.disabled = true;
      elements.mismatchBtn.textContent =
        elements.mismatchBtn.dataset.default || "Move to mismatch queue";
    }
    elements.container.classList.add("hidden");
  }

  function hydratePreviewStateFromCache(folderId, payload, previewData, rootFolder) {
    if (!payload) {
      return;
    }
    const basePayload = payload.base_payload || { folder_id: folderId };
    const finalPayload = payload.final_payload || basePayload;
    previewState.set(folderId, {
      folderId,
      basePayload,
      finalPayload,
      payload: finalPayload,
      previewData,
      contact: previewData?.contacts?.primary || null,
      deal: payload.deal || previewData?.deal || null,
      rootFolder,
      collaborator: payload.collaborator || null,
    });
  }

  function renderCachedPreview(folderId, payload, options = {}) {
    const elements = getPreviewElements(folderId);
    if (!elements) return;
    const previewData = payload.preview || {};
    const rootFolder =
      payload.root_folder
      || previewData.root_folder
      || {
        id: folderId,
        name: "",
        url: `https://app.box.com/folder/${folderId}`,
      };
    resetPreviewDisplay(folderId);
    elements.container.classList.remove("hidden");
    if (payload.status !== "ok" || !previewData.metadata_fields) {
      const reason = payload.error || "Cached preview unavailable.";
      setPreviewStatus(folderId, reason, true);
      addPipelineStep(folderId, reason, "error");
      return;
    }
    renderPreviewSummary(folderId, previewData, payload.deal || previewData.deal, rootFolder);
    renderMetadataTable(folderId, previewData.metadata_fields);
    hydratePreviewStateFromCache(folderId, payload, previewData, rootFolder);
    const generatedAt = payload.generated_at || payload.generated_at_iso || "";
    const sourceLabel = payload.source === "refreshed" ? "Refreshed preview" : "Cached preview";
    const statusMessage = generatedAt ? `${sourceLabel} ¬∑ ${generatedAt}` : `${sourceLabel} loaded`;
    setPreviewStatus(folderId, statusMessage);
    addPipelineStep(folderId, statusMessage, "success");
    if (elements.applyBtn) {
      elements.applyBtn.classList.remove("hidden");
      if (payload.final_payload) {
        elements.applyBtn.disabled = false;
        elements.applyBtn.dataset.default =
          elements.applyBtn.dataset.default || elements.applyBtn.textContent;
      } else {
        elements.applyBtn.disabled = true;
      }
    }
    if (elements.mismatchBtn) {
      elements.mismatchBtn.classList.remove("hidden");
      elements.mismatchBtn.disabled = false;
      elements.mismatchBtn.dataset.default =
        elements.mismatchBtn.dataset.default || elements.mismatchBtn.textContent;
    }
    if (elements.mismatchBtn) {
      elements.mismatchBtn.classList.remove("hidden");
      elements.mismatchBtn.disabled = false;
      elements.mismatchBtn.dataset.default =
        elements.mismatchBtn.dataset.default || elements.mismatchBtn.textContent;
    }
  }

  async function tryLoadCachedPreview(folderId, button, options = {}) {
    if (!PREVIEW_CACHE_ENABLED) {
      return false;
    }
    const refresh = options.refresh === true;
    try {
      setBusy(button, true, refresh ? "Refreshing‚Ä¶" : "Loading‚Ä¶");
      const cached = await fetchCachedPreview(folderId, { refresh });
      if (!cached) {
        const message = cached?.error || "Cached preview not available.";
        setPreviewStatus(folderId, message, true);
        addPipelineStep(folderId, message, "error");
        return false;
      }
      renderCachedPreview(folderId, cached, { refresh });
      button.dataset.cacheLoaded = refresh ? "refreshed" : "cached";
      return cached.status === "ok";
    } catch (error) {
      console.warn("Cached preview load failed", error);
      return false;
    } finally {
      setBusy(button, false);
    }
  }

  function clearPreviewState(folderId, options = {}) {
    previewState.delete(folderId);
    previewContainers.delete(String(folderId ?? ""));
    const elements = getPreviewElements(folderId);
    if (!elements) return;
    if (elements.status) {
      elements.status.textContent = "";
      elements.status.classList.remove("error");
    }
    if (elements.summary) {
      elements.summary.classList.add("hidden");
      elements.summary.innerHTML = "";
    }
    if (elements.metadata) {
      elements.metadata.classList.add("hidden");
      elements.metadata.innerHTML = "";
    }
    if (elements.pipeline) {
      elements.pipeline.classList.add("hidden");
      elements.pipeline.innerHTML = "";
    }
    if (elements.applyBtn) {
      elements.applyBtn.classList.add("hidden");
      elements.applyBtn.disabled = true;
      const label =
        elements.applyBtn.dataset.default || "Apply metadata and Box folder tagging";
      elements.applyBtn.textContent = label;
    }
    if (elements.container) {
      if (options.keepVisible) {
        elements.container.classList.remove("hidden");
      } else {
        elements.container.classList.add("hidden");
      }
    }
  }

  function setPreviewStatus(folderId, message, isError = false) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.status) return;
    elements.status.textContent = message;
    if (isError) {
      elements.status.classList.add("error");
    } else {
      elements.status.classList.remove("error");
    }
  }

  function addPipelineStep(folderId, message, level = "info") {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.pipeline) return;
    elements.pipeline.classList.remove("hidden");
    const span = document.createElement("span");
    span.textContent = message;
    span.classList.add(`status-${level}`);
    elements.pipeline.appendChild(span);
  }

  function parseTimestamp(value) {
    if (!value && value !== 0) return 0;
    if (typeof value === "number") return value;
    const str = String(value).trim();
    if (!str) return 0;
    if (/^\d+$/.test(str)) {
      const num = Number(str);
      if (Number.isNaN(num)) return 0;
      return num > 1e12 ? num : num * 1000;
    }
    const parsed = Date.parse(str);
    return Number.isNaN(parsed) ? 0 : parsed;
  }

  function extractDealTimestamp(deal) {
    const props = (deal && deal.properties) || {};
    const candidates = [
      props.agreement_start_date,
      props.closedate,
      props.hs_closed_won_date,
      deal?.updatedAt,
      deal?.createdAt,
    ];
    for (const candidate of candidates) {
      const ts = parseTimestamp(candidate);
      if (ts) return ts;
    }
    return 0;
  }

  function formatDate(ts) {
    if (!ts) return "n/a";
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return "n/a";
    return d.toISOString().slice(0, 10);
  }

  function extractPortalIdFromUrl(url) {
    if (!url) return "";
    const match = String(url).match(/contacts\/(\d+)\/record/);
    return match ? match[1] : "";
  }

  function buildContactLink(portalId, contactId) {
    if (!portalId || !contactId) return undefined;
    return `https://app.hubspot.com/contacts/${portalId}/record/0-1/${contactId}`;
  }

  function formatAssociatedContact({ name, email, id, link }) {
    const parts = [];
    if (email) parts.push(email);
    if (id) parts.push(`ID: ${id}`);
    if (link) parts.push(`Link: ${link}`);
    if (!parts.length) return name || "Contact";
    return `${name || "Contact"} (${parts.join(" | ")})`;
  }

  function buildMetadataPreview(payload, deal, contact) {
    const primaryName = [payload.hs_contact_firstname, payload.hs_contact_lastname]
      .filter(Boolean)
      .join(" ")
      .trim();
    const spouseName = [payload.hs_spouse_firstname, payload.hs_spouse_lastname]
      .filter(Boolean)
      .join(" ")
      .trim();

    const portalId = extractPortalIdFromUrl(contact?.url);
    const primaryLink = contact?.url || buildContactLink(portalId, payload.hs_contact_id);
    const spouseLink = buildContactLink(portalId, payload.hs_spouse_id);

    const associatedIdSet = new Set();
    const associatedContacts = [];
    const seenContactKeys = new Set();

    const pushAssociatedContact = ({ name, email, id, link }) => {
      const trimmedId = (id || "").trim();
      const key = `${trimmedId}|${(email || name || "").toLowerCase()}`;
      if (key && seenContactKeys.has(key)) {
        return;
      }
      if (key) {
        seenContactKeys.add(key);
      }
      if (trimmedId) {
        associatedIdSet.add(trimmedId);
      }
      associatedContacts.push(
        formatAssociatedContact({
          name: name || "Contact",
          email: email || "",
          id: trimmedId,
          link,
        }),
      );
    };

    if (primaryName || payload.hs_contact_id || payload.hs_contact_email) {
      pushAssociatedContact({
        name: primaryName || "Primary Contact",
        email: payload.hs_contact_email || "",
        id: payload.hs_contact_id || "",
        link: primaryLink,
      });
    }
    if (spouseName || payload.hs_spouse_id || payload.hs_spouse_email) {
      pushAssociatedContact({
        name: spouseName || "Spouse",
        email: payload.hs_spouse_email || "",
        id: payload.hs_spouse_id || "",
        link: spouseLink,
      });
    }

    const metadataFields = {
      deal_salutation: payload.deal_salutation || "",
      household_type: payload.household_type || "",
      primary_contact_id: payload.hs_contact_id || "",
      primary_contact_link: primaryLink || "",
      hs_spouse_id: payload.hs_spouse_id || "",
      spouse_contact_link: spouseLink || "",
    };

    const dealDetails = (() => {
      if (!deal) return undefined;
      const props = deal.properties || {};
      return {
        id: props.hs_deal_record_id || deal.id || "",
        name: props.dealname || "",
        stage: props.dealstage || "",
        close_date: formatDate(extractDealTimestamp(deal)) || "",
      };
    })();

    return {
      folder_id: payload.folder_id,
      deal_id: payload.deal_id,
      deal: dealDetails,
      metadata_fields: metadataFields,
      contacts: {
        primary: {
          id: payload.hs_contact_id || "",
          name: primaryName || "",
          email: payload.hs_contact_email || "",
          link: primaryLink || "",
        },
        spouse: {
          id: payload.hs_spouse_id || "",
          name: spouseName || "",
          email: payload.hs_spouse_email || "",
          link: spouseLink || "",
          firstname: payload.hs_spouse_firstname || "",
          lastname: payload.hs_spouse_lastname || "",
        },
        additional: associatedContacts,
      },
    };
  }

  function buildContactSummary(contact) {
    if (!contact) {
      return "‚Äî";
    }
    const name =
      contact.name ||
      [contact.firstname, contact.lastname].filter(Boolean).join(" ").trim();
    const parts = [];
    if (name) {
      parts.push(`<strong>${escapeHtml(name)}</strong>`);
    }
    if (contact.email) {
      parts.push(`<span class="muted small">${escapeHtml(contact.email)}</span>`);
    }
    if (contact.id) {
      parts.push(`<span class="muted small">ID: ${escapeHtml(contact.id)}</span>`);
    }
    if (contact.link) {
      parts.push(
        `<a href="${escapeHtml(contact.link)}" target="_blank" rel="noopener">HubSpot</a>`,
      );
    }
    return parts.length ? parts.join("<br/>") : "‚Äî";
  }

  function isMetadataValueEmpty(value) {
    if (value === null || value === undefined) {
      return true;
    }
    if (typeof value === "string") {
      return value.trim() === "";
    }
    if (Array.isArray(value)) {
      return value.length === 0;
    }
    if (typeof value === "object") {
      return Object.keys(value).length === 0;
    }
    return false;
  }

  function formatMetadataValue(value) {
    if (
      value === null
      || value === undefined
      || (typeof value === "string" && value.trim() === "")
    ) {
      return '<span class="muted small">‚Äî</span>';
    }
    if (typeof value === "object") {
      try {
        const serialized = JSON.stringify(value, null, 2);
        return `<pre>${escapeHtml(serialized)}</pre>`;
      } catch (error) {
        return `<pre>${escapeHtml(String(value))}</pre>`;
      }
    }
    return escapeHtml(String(value));
  }

  function buildMetadataTableRows(fields) {
    const entries = Object.entries(fields || {}).filter(([, value]) => !isMetadataValueEmpty(value));
    if (!entries.length) {
      return '<tr><td colspan="2">No metadata fields populated.</td></tr>';
    }
    return entries
      .map(
        ([key, value]) =>
          `<tr><td>${escapeHtml(key)}</td><td>${formatMetadataValue(value)}</td></tr>`,
      )
      .join("");
  }

  function selectBestDeal(deals) {
    if (!Array.isArray(deals) || !deals.length) {
      return null;
    }
    const sorted = [...deals].sort(
      (a, b) => extractDealTimestamp(b) - extractDealTimestamp(a),
    );
    return sorted[0];
  }

  function buildBasePayload(folderId, contact, selectedDeal) {
    const payload = { folder_id: folderId };
    const dealProps = (selectedDeal && selectedDeal.properties) || {};
    const dealId = String(dealProps.hs_deal_record_id || selectedDeal?.id || "").trim();
    if (dealId) {
      payload.deal_id = dealId;
      payload.hs_deal_record_id = dealId;
    }
    const contactProps = (contact && contact.properties) || {};
    if (contact && contact.id) payload.hs_contact_id = contact.id;
    if (contactProps.firstname) payload.hs_contact_firstname = contactProps.firstname;
    if (contactProps.lastname) payload.hs_contact_lastname = contactProps.lastname;
    if (contactProps.email) payload.hs_contact_email = contactProps.email;
    if (dealProps.hs_spouse_id && !payload.hs_spouse_id) payload.hs_spouse_id = dealProps.hs_spouse_id;
    if (dealProps.hs_spouse_firstname && !payload.hs_spouse_firstname) payload.hs_spouse_firstname = dealProps.hs_spouse_firstname;
    if (dealProps.hs_spouse_lastname && !payload.hs_spouse_lastname) payload.hs_spouse_lastname = dealProps.hs_spouse_lastname;
    if (dealProps.hs_spouse_email && !payload.hs_spouse_email) payload.hs_spouse_email = dealProps.hs_spouse_email;
    if (dealProps.deal_salutation && !payload.deal_salutation) payload.deal_salutation = dealProps.deal_salutation;
    if (dealProps.household_type && !payload.household_type) payload.household_type = dealProps.household_type;

    return payload;
  }

  function buildPayloadForApply(basePayload, previewData) {
    const payload = { ...basePayload };
    const metadataFields = previewData?.metadata_fields || {};
    Object.entries(metadataFields).forEach(([key, value]) => {
      if (!isMetadataValueEmpty(value)) {
        payload[key] = value;
      }
    });
    return payload;
  }

  function renderPreviewSummary(folderId, previewData, deal, rootFolder) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.summary) return;
    const folderName = rootFolder?.name || rootFolder?.path || previewData.folder_id || folderId;
    const folderLink = rootFolder?.url
      ? `<a href="${escapeHtml(rootFolder.url)}" target="_blank" rel="noopener">${escapeHtml(folderName)}</a>`
      : escapeHtml(folderName);
    const contacts = previewData.contacts || {};
    const dealInfo = previewData.deal || {};
    const dealUrl = deal?.url;
    const dealLabel = escapeHtml(dealInfo.name || dealInfo.id || "n/a");
    const dealLink = dealUrl
      ? `<a href="${escapeHtml(dealUrl)}" target="_blank" rel="noopener">${dealLabel}</a>`
      : dealLabel;

    elements.summary.innerHTML = `
      <h4>Metadata preview</h4>
      <p><strong>Box folder:</strong> <span>${folderLink}</span></p>
      <p><strong>Primary contact:</strong> <span>${buildContactSummary(contacts.primary)}</span></p>
      <p><strong>Spouse:</strong> <span>${buildContactSummary(contacts.spouse)}</span></p>
      <p><strong>Deal:</strong> <span>${dealLink} ¬∑ Stage: ${escapeHtml(dealInfo.stage || "n/a")} ¬∑ Close: ${escapeHtml(dealInfo.close_date || "n/a")}</span></p>
    `;
    elements.summary.classList.remove("hidden");
  }

  function renderMetadataTable(folderId, metadataFields) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.metadata) return;
    const rows = buildMetadataTableRows(metadataFields);
    elements.metadata.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
    elements.metadata.classList.remove("hidden");
  }

  async function loadPreviewForFolder(folderId, button) {
    const elements = getPreviewElements(folderId, button);
    if (!elements) return;
    previewState.delete(folderId);
    resetPreviewDisplay(folderId, button);
    elements.container.classList.remove("hidden");
    setPreviewStatus(folderId, "Preparing preview‚Ä¶");
    setBusy(button, true, "Loading‚Ä¶");
    const aggregatedAll = new Map();
    const aggregatedExternal = new Map();

    const registerCollaborator = (collab, contextLabel) => {
      if (!collab || !collab.email) return;
      const key = String(collab.email).trim().toLowerCase();
      if (!key) return;
      if (!aggregatedAll.has(key)) {
        aggregatedAll.set(key, { collab, context: contextLabel || "Folder" });
      }
      if (!key.endsWith(PIVOT_DOMAIN) && !aggregatedExternal.has(key)) {
        aggregatedExternal.set(key, { collab, context: contextLabel || "Folder" });
      }
    };

    const registerFromResponse = (data, contextLabel) => {
      const collaborators = Array.isArray(data?.collaborators) ? data.collaborators : [];
      collaborators.forEach((collab) => registerCollaborator(collab, contextLabel));
    };

    try {
      addPipelineStep(folderId, "Fetching collaborators‚Ä¶", "info");
      const collaboratorsData = await fetchJSON(
        `/box/folder/collaborators?folder_id=${encodeURIComponent(folderId)}&include_subfolders=1`,
      );
      addPipelineStep(folderId, "Root collaborators loaded", "success");
      registerFromResponse(collaboratorsData, "Root folder");

      const subfolders = Array.isArray(collaboratorsData.subfolders)
        ? collaboratorsData.subfolders
        : [];
      for (const sub of subfolders) {
        const label = sub.name || sub.id || "Subfolder";
        addPipelineStep(folderId, `Scanning subfolder ${label}‚Ä¶`, "info");
        try {
          const subData = await fetchJSON(
            `/box/folder/collaborators?folder_id=${encodeURIComponent(
              folderId,
            )}&subfolder_id=${encodeURIComponent(sub.id)}&subfolder=${encodeURIComponent(sub.name || "")}`,
          );
          registerFromResponse(subData, `Subfolder ${label}`);
          addPipelineStep(folderId, `Subfolder ${label} processed`, "success");
        } catch (error) {
          console.error(error);
          addPipelineStep(
            folderId,
            `Failed to scan subfolder ${label}: ${error.message}`,
            "error",
          );
        }
      }

      const externalList = Array.from(aggregatedExternal.values());
      const allList = Array.from(aggregatedAll.values());
      if (!externalList.length && allList.length) {
        addPipelineStep(
          folderId,
          "No external collaborators detected; using first available collaborator.",
          "info",
        );
      }
      const chosenRecord = externalList[0] || allList[0] || null;
      const chosen = chosenRecord?.collab || null;
      if (!chosen || !chosen.email) {
        setPreviewStatus(folderId, "Unable to generate preview ¬∑ no collaborators found.", true);
        addPipelineStep(folderId, "No collaborators returned", "error");
        return;
      }

      addPipelineStep(
        folderId,
        `Selected collaborator ${chosen.email}${chosenRecord?.context ? ` (${chosenRecord.context})` : ""}`,
        "info",
      );
      const contactData = await fetchJSON(
        `/box/collaborators/contact?email=${encodeURIComponent(chosen.email)}`,
      );
      addPipelineStep(folderId, "HubSpot contact loaded", "success");

      const deals = Array.isArray(contactData?.deals) ? contactData.deals : [];
      const selectedDeal = selectBestDeal(deals);
      if (!selectedDeal) {
        setPreviewStatus(folderId, "No associated deals found in HubSpot.", true);
        addPipelineStep(folderId, "No deals associated with contact", "error");
        return;
      }

      addPipelineStep(
        folderId,
        `Selected deal ${escapeHtml(selectedDeal.properties?.dealname || selectedDeal.id || "n/a")}`,
        "info",
      );

      const rootFolder = collaboratorsData.root_folder || {
        id: folderId,
        name: collaboratorsData?.inspected?.name || "",
        url: `https://app.box.com/folder/${folderId}`,
      };

      const basePayload = buildBasePayload(folderId, contactData.contact, selectedDeal);
      const previewData = buildMetadataPreview(basePayload, selectedDeal, contactData.contact);
      const finalPayload = buildPayloadForApply(basePayload, previewData);
      renderPreviewSummary(folderId, previewData, selectedDeal, rootFolder);
      renderMetadataTable(folderId, previewData.metadata_fields);

      const metadataFields = previewData.metadata_fields || {};
      const hasMetadataContent = Object.entries(metadataFields).some(
        ([, value]) => !isMetadataValueEmpty(value),
      );
      if (!hasMetadataContent) {
        addPipelineStep(folderId, "Metadata fields missing or blank", "error");
        setPreviewStatus(
          folderId,
          "Preview generated but metadata fields are incomplete.",
          true,
        );
        previewState.set(folderId, {
          folderId,
          basePayload,
          finalPayload,
          payload: finalPayload,
          previewData,
          contact: contactData.contact,
          deal: selectedDeal,
          rootFolder,
          collaborator: chosen,
        });
        return;
      }

      previewState.set(folderId, {
        folderId,
        basePayload,
        finalPayload,
        payload: finalPayload,
        previewData,
        contact: contactData.contact,
        deal: selectedDeal,
        rootFolder,
        collaborator: chosen,
      });
      setPreviewStatus(folderId, "Preview ready. Review and apply when ready.");
      addPipelineStep(folderId, "Metadata preview generated", "success");

      if (elements.applyBtn) {
        elements.applyBtn.classList.remove("hidden");
        elements.applyBtn.disabled = false;
        elements.applyBtn.dataset.default = elements.applyBtn.dataset.default || elements.applyBtn.textContent;
      }
      if (elements.mismatchBtn) {
        elements.mismatchBtn.classList.remove("hidden");
        elements.mismatchBtn.disabled = false;
        elements.mismatchBtn.dataset.default =
          elements.mismatchBtn.dataset.default || elements.mismatchBtn.textContent;
      }
    } catch (error) {
      console.error(error);
      setPreviewStatus(folderId, `Preview failed ¬∑ ${error.message}`, true);
      addPipelineStep(folderId, error.message, "error");
    } finally {
      setBusy(button, false);
    }
  }

  async function applyMetadataForFolder(folderId, button) {
    const state = previewState.get(folderId);
    const elements = getPreviewElements(folderId, button);
    if (!state) {
      setPreviewStatus(folderId, "Generate preview before applying metadata.", true);
      return;
    }
    const finalPayload =
      state.finalPayload
      || state.payload
      || (state.basePayload && state.previewData
        ? buildPayloadForApply(state.basePayload, state.previewData)
        : null);
    if (!finalPayload) {
      setPreviewStatus(folderId, "Preview payload is unavailable; regenerate preview.", true);
      return;
    }
    const defaultLabel = button ? (button.dataset.default || button.textContent) : "";
    if (button) {
      button.dataset.default = defaultLabel;
      button.textContent = "Applying‚Ä¶";
      button.disabled = true;
    }
    setPreviewStatus(folderId, "Applying metadata and updating HubSpot‚Ä¶");
    addPipelineStep(folderId, "Applying metadata via API‚Ä¶", "info");
    try {
      const response = await fetchJSON("/box/folder/tag/auto", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(finalPayload),
      });
      addPipelineStep(folderId, "Metadata applied in Box", "success");
      addPipelineStep(folderId, "HubSpot update completed", "success");
      setPreviewStatus(
        folderId,
        `Metadata applied successfully to folder ${escapeHtml(response.folder_id)}.`,
      );
      if (button) {
        button.dataset.default = "Metadata applied";
        button.textContent = "Metadata applied";
        button.disabled = true;
      }
    } catch (error) {
      console.error(error);
      setPreviewStatus(folderId, `Apply failed ¬∑ ${error.message}`, true);
      addPipelineStep(folderId, error.message, "error");
      if (button) {
        button.disabled = false;
        button.textContent = defaultLabel || "Apply metadata and Box folder tagging";
      }
      return;
    } finally {
      if (button && !button.disabled) {
        button.textContent = button.dataset.default || defaultLabel || button.textContent;
      }
    }
  }

  document.querySelectorAll(".preview-link").forEach((button) => {
    button.addEventListener("click", async (event) => {
      const folderId = button.dataset.folderId;
      if (!folderId) return;
      const forceRefresh = event.shiftKey || event.metaKey || event.altKey || event.ctrlKey;
      const usedCache = await tryLoadCachedPreview(folderId, button, { refresh: forceRefresh });
      if (!usedCache) {
        loadPreviewForFolder(folderId, button);
      }
    });
  });

  document.querySelectorAll(".apply-link").forEach((button) => {
    button.addEventListener("click", () => {
      const folderId = button.dataset.folderId;
      if (!folderId) return;
      applyMetadataForFolder(folderId, button);
    });
  });
</script>
{% endblock %}

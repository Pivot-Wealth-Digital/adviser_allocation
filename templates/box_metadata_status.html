{% extends "layout.html" %}
{% set title = "Box Metadata Snapshot" %}

{% block content %}
<div class="topbar">
  <div style="display:flex;align-items:center;gap:16px;">
    <a href="/box/collaborators" style="color:#d0d7e2;text-decoration:none;font-size:0.9em;">‚Üê Box Tools</a>
    <h2>Box Metadata Snapshot</h2>
  </div>
  <div class="topbar-right">
    <a class="guide-link" href="/box/folder/metadata/guide" target="_blank" rel="noopener">
      Tagging Guide
    </a>
    <div class="datebox">
      <span>Today: {{ today }}</span>
      <span>Updated: {{ updated_at_display or "Not cached yet" }}</span>
    </div>
  </div>
</div>

{% if error_message %}
<div class="card">
  <h3>Snapshot unavailable</h3>
  <p class="muted">{{ error_message }}</p>
  <p class="muted small">Enable Firestore or check service access to view the cached metadata status.</p>
</div>
{% else %}
<div class="card summary-card">
  <div class="summary-grid">
    <div class="summary-tile tagged">
      <span class="label">Tagged</span>
      <span class="metric">{{ counts.tagged }}</span>
    </div>
    <div class="summary-tile untagged">
      <span class="label">Untagged</span>
      <span class="metric">{{ counts.untagged }}</span>
    </div>
    <div class="summary-tile issues">
      <span class="label">Issues</span>
      <span class="metric">{{ counts.issues }}</span>
    </div>
  </div>
  <p class="muted small">
    Snapshot stored in Firestore at <code>box_folder_metadata/tagging_status</code>.
  </p>
</div>

{% if assignment_slots %}
<details class="card collapsible assignment-card" open>
  <summary>Assignment queues ({{ assignment_slots|length }})</summary>
  <p class="muted small">
    Slots computed from <code>folder_id % {{ assignment_slots|length }}</code> so every refresh keeps the same owner.
    Provide your own labels using <code>?assignees=Alex,Bianca,...</code>.
  </p>
  <div class="assignment-grid">
    {% for slot in assignment_slots %}
    <details class="assignment-slot">
      <summary>
        <span class="slot-name">{{ slot.assignee }}</span>
        <span class="slot-count">{{ slot.count }} folders</span>
      </summary>
      {% if slot.folders %}
      <ul class="folder-list compact">
        {% for folder in slot.folders %}
        <li>
          <div class="folder-meta">
            {% set display_name = folder.name or folder.id %}
            <span class="folder-name">{{ display_name }}</span>
            {% if folder.id and folder.id != display_name %}
            <span class="folder-id"><code>{{ folder.id }}</code></span>
            {% endif %}
            {% if folder.path %}
            <span class="folder-path muted small">{{ folder.path }}</span>
            {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
      </div>
    </li>
    {% endfor %}
  </ul>
      {% else %}
      <p class="muted small">No folders currently allocated to this slot.</p>
      {% endif %}
    </details>
    {% endfor %}
  </div>
</details>
{% endif %}

<details class="card collapsible" {% if counts.untagged and counts.untagged <= 40 %}open{% endif %}>
  <summary>Untagged folders ({{ counts.untagged }})</summary>
  {% if not snapshot_exists %}
  <p class="muted">No metadata snapshot has been captured yet. Refresh to load the latest folder status.</p>
  {% elif untagged_entries %}
  <p class="muted">These folders still need the metadata template applied.</p>
  <ul class="folder-list">
    {% for folder in untagged_entries %}
    <li>
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted">All tracked folders currently have metadata applied.</p>
  {% endif %}
</details>

<details class="card collapsible" {% if counts.tagged and counts.tagged <= 40 %}open{% endif %}>
  <summary>Tagged folders ({{ counts.tagged }})</summary>
  {% if not snapshot_exists %}
  <p class="muted">No folders captured yet. Refresh the snapshot to record the current state.</p>
  {% elif tagged_entries %}
  <ul class="folder-list compact">
    {% for folder in tagged_entries %}
    <li>
      <div class="folder-meta">
        {% set display_name = folder.name or folder.id %}
        <span class="folder-name">{{ display_name }}</span>
        {% if folder.id and folder.id != display_name %}
        <span class="folder-id"><code>{{ folder.id }}</code></span>
        {% endif %}
        {% if folder.path %}
        <span class="folder-path muted small">{{ folder.path }}</span>
        {% endif %}
        {% if folder.tagged_at %}
        <span class="folder-tagged muted small">Tagged at {{ folder.tagged_at }}</span>
        {% endif %}
      </div>
      <div class="folder-actions">
        {% if folder.url %}
        <a href="{{ folder.url }}" target="_blank" rel="noopener">Open in Box</a>
        {% else %}
        <span class="muted small">No URL captured</span>
        {% endif %}
        <button type="button" class="secondary collab-link" data-folder-id="{{ folder.id }}">Collaborators</button>
        <button type="button" class="secondary preview-link" data-folder-id="{{ folder.id }}">Preview metadata</button>
      </div>
      <div class="folder-preview hidden" data-preview-container="{{ folder.id }}">
        <p class="preview-status muted small" data-preview-status="{{ folder.id }}"></p>
        <div class="preview-summary hidden" data-preview-summary="{{ folder.id }}"></div>
        <div class="preview-metadata hidden" data-preview-metadata="{{ folder.id }}"></div>
        <div class="preview-pipeline hidden" data-preview-pipeline="{{ folder.id }}"></div>
        <button
          type="button"
          class="secondary apply-link hidden"
          data-folder-id="{{ folder.id }}"
        >
          Apply metadata and Box folder tagging
        </button>
      </div>
    </li>
    {% endfor %}
  </ul>
  {% else %}
  <p class="muted">No tagged folders recorded in the snapshot yet.</p>
  {% endif %}
</details>

{% if issues %}
<div class="card warning-card">
  <h3>Scan issues</h3>
  <p class="muted small">The following folders could not be inspected during the last scan:</p>
  <ul class="issue-list">
    {% for issue in issues %}
    <li>{{ issue }}</li>
    {% endfor %}
  </ul>
</div>
{% endif %}
{% endif %}
{% if allow_refresh %}
<div class="refresh-footer">
  <button id="refresh-btn" class="secondary refresh-btn" data-default="Refresh snapshot">
    Refresh snapshot
  </button>
  <span id="refresh-status" class="muted small"></span>
</div>
{% endif %}
{% endblock %}

{% block head %}
<style>
  .summary-card {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .topbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .guide-link {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9em;
    font-weight: 600;
    padding: 8px 14px;
    border-radius: 999px;
    background: linear-gradient(135deg, #6366f1, #4338ca);
    color: #ffffff;
    text-decoration: none;
    box-shadow: 0 6px 18px rgba(99, 102, 241, 0.35);
    transition: transform 0.1s ease, box-shadow 0.1s ease;
  }

  .guide-link::before {
    content: "üìò";
    font-size: 1.05em;
  }

  .guide-link:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 24px rgba(67, 56, 202, 0.45);
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
  }

  .summary-tile {
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    background: rgba(15, 23, 42, 0.03);
  }

  .summary-tile .label {
    display: block;
    font-size: 0.85em;
    color: var(--muted);
    margin-bottom: 4px;
  }

  .summary-tile .metric {
    font-size: 1.8em;
    font-weight: 600;
  }

  .summary-tile.tagged {
    border-color: rgba(34, 197, 94, 0.35);
    background: rgba(34, 197, 94, 0.08);
  }

  .summary-tile.untagged {
    border-color: rgba(239, 68, 68, 0.25);
    background: rgba(239, 68, 68, 0.08);
  }

  .summary-tile.issues {
    border-color: rgba(249, 115, 22, 0.3);
    background: rgba(249, 115, 22, 0.1);
  }

  .folder-list {
    list-style: none;
    padding: 0;
    margin: 12px 0 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .folder-list li {
    display: flex;
    align-items: center;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    background: #fff;
    gap: 12px;
    justify-content: space-between;
  }

  .folder-list.compact {
    flex-direction: column;
  }

  .folder-list.compact li {
    justify-content: space-between;
  }

  .folder-list code {
    font-size: 0.9em;
  }

  .folder-meta {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-width: 75%;
  }

  .folder-name {
    font-weight: 600;
  }

  .folder-path {
    word-break: break-word;
  }

  .folder-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
  }

  .folder-list a {
    font-size: 0.85em;
    color: var(--brand);
  }

  .assignment-card {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .assignment-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .assignment-slot {
    border: 1px solid var(--border);
    border-radius: 10px;
    background: rgba(15, 23, 42, 0.03);
    padding: 12px;
  }

  .assignment-slot[open] {
    background: rgba(15, 23, 42, 0.05);
  }

  .assignment-slot summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .assignment-slot summary::-webkit-details-marker {
    display: none;
  }

  .slot-count {
    font-size: 0.85em;
    color: var(--muted);
  }

  .assignment-slot .folder-list {
    margin-top: 8px;
  }

  .refresh-footer {
    margin-top: 24px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .refresh-btn {
    padding: 6px 10px;
    font-size: 0.85em;
    color: #4b5563;
    border-color: #d1d5db;
    background: #f3f4f6;
  }

  .refresh-btn:hover {
    background: #e5e7eb;
    border-color: #cbd5f5;
  }

  .hidden {
    display: none !important;
  }

  .folder-preview {
    margin-top: 12px;
    padding: 12px 14px;
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(241, 245, 249, 0.5);
    display: grid;
    gap: 10px;
  }

  .preview-status {
    margin: 0;
    color: #475569;
  }

  .preview-status.error {
    color: #b91c1c;
    font-weight: 600;
  }

  .preview-summary {
    background: #ffffff;
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.4);
    padding: 12px 14px;
    box-shadow: 0 10px 22px rgba(15, 23, 42, 0.08);
  }

  .preview-summary h4 {
    margin: 0 0 6px;
    font-size: 0.95rem;
    color: #1f2937;
  }

  .preview-summary p {
    margin: 2px 0;
    font-size: 0.9rem;
    color: #334155;
  }

  .preview-summary p span {
    display: inline-block;
    margin-left: 6px;
  }

  .preview-summary a {
    color: #2563eb;
  }

  .preview-metadata table {
    width: 100%;
    border-collapse: collapse;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.35);
    background: #fff;
  }

  .preview-metadata th,
  .preview-metadata td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.25);
    text-align: left;
    font-size: 0.88rem;
  }

  .preview-metadata th {
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    color: #475569;
    background: rgba(241, 245, 249, 0.7);
  }

  .preview-metadata td pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 0.82rem;
  }

  .preview-pipeline {
    border-left: 3px solid rgba(99, 102, 241, 0.55);
    padding-left: 12px;
    display: grid;
    gap: 4px;
  }

  .preview-pipeline span {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .preview-pipeline .status-info::before {
    content: "‚Ä¢";
    color: #4338ca;
  }

  .preview-pipeline .status-success::before {
    content: "‚Ä¢";
    color: #0f766e;
  }

  .preview-pipeline .status-error::before {
    content: "‚Ä¢";
    color: #b91c1c;
  }

  .folder-preview .apply-link {
    justify-self: start;
  }
  .warning-card {
    border: 1px solid rgba(249, 115, 22, 0.4);
    background: rgba(249, 115, 22, 0.12);
  }

  .issue-list {
    margin: 8px 0 0;
    padding-left: 1.2rem;
  }

  details.collapsible summary {
    cursor: pointer;
    font-weight: 600;
    margin-bottom: 8px;
  }

  details.collapsible[open] summary {
    margin-bottom: 12px;
  }

</style>
{% endblock %}

{% block scripts %}
<script>
  const refreshBtn = document.getElementById("refresh-btn");
  if (refreshBtn) {
    const status = document.getElementById("refresh-status");
    refreshBtn.addEventListener("click", async () => {
      status.textContent = "";
      status.classList.remove("err");
      const defaultLabel = refreshBtn.dataset.default || "Refresh snapshot";
      refreshBtn.disabled = true;
      refreshBtn.textContent = "Refreshing‚Ä¶";
      try {
        const response = await fetch("/box/folder/metadata/cache", { method: "POST" });
        if (!response.ok) {
          let detail = "";
          try {
            const payload = await response.json();
            detail = payload.message || payload.error || "";
          } catch (_) {
            detail = "";
          }
          throw new Error(detail || response.statusText);
        }
        refreshBtn.textContent = "Reloading‚Ä¶";
        status.textContent = "Snapshot refreshed. Reloading‚Ä¶";
        window.setTimeout(() => window.location.reload(), 600);
      } catch (error) {
        refreshBtn.disabled = false;
        refreshBtn.textContent = defaultLabel;
        status.textContent = `Failed to refresh: ${error.message}`;
        status.classList.add("err");
      }
    });
  }

  document.querySelectorAll(".collab-link").forEach((button) => {
    button.addEventListener("click", () => {
      const folderId = button.dataset.folderId;
      if (!folderId) {
        return;
      }
      const url = `/box/collaborators?folder_id=${encodeURIComponent(folderId)}`;
      const win = window.open(url, "_blank");
      if (win) {
        win.opener = null;
      }
    });
  });

  const previewState = new Map();
  const previewContainers = new Map();
  const PIVOT_DOMAIN = "@pivotwealth.com.au";

  function setBusy(button, busy, label) {
    if (!button) return;
    if (busy) {
      button.dataset.default = button.dataset.default || button.textContent;
      button.textContent = label || "Working‚Ä¶";
      button.disabled = true;
    } else {
      button.textContent = button.dataset.default || button.textContent;
      button.disabled = false;
    }
  }

  async function fetchJSON(url, options) {
    let response;
    try {
      response = await fetch(url, options);
    } catch (error) {
      throw new Error(`Network error: ${error.message}`);
    }
    const contentType = response.headers.get("content-type") || "";
    const isJSON = contentType.includes("application/json");
    let data = null;
    if (isJSON) {
      try {
        data = await response.json();
      } catch (error) {
        throw new Error("Invalid JSON response received");
      }
    } else {
      const text = await response.text();
      data = text ? { raw: text } : null;
    }
    if (!response.ok) {
      const message = (data && (data.message || data.error)) || response.statusText;
      const error = new Error(message);
      if (data && data.detail) {
        error.detail = data.detail;
      }
      throw error;
    }
    return data;
  }

  function escapeHtml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function escapeAttr(value) {
    return String(value ?? "").replace(/"/g, '\\"');
  }

  function getPreviewElements(folderId, hintElement) {
    const key = String(folderId ?? "");
    if (!key) {
      return null;
    }
    const attrValue = escapeAttr(key);
    let container = null;
    if (hintElement instanceof Element) {
      if (hintElement.matches(`[data-preview-container]`)) {
        container = hintElement;
      } else {
        const direct = hintElement.closest(`[data-preview-container]`);
        if (direct) {
          container = direct;
        } else {
          const host = hintElement.closest("li");
          if (host) {
            container = host.querySelector(`[data-preview-container="${attrValue}"]`);
          }
        }
      }
    }
    if (!container) {
      container = previewContainers.get(key) || null;
    }
    if (!container) {
      container = document.querySelector(`[data-preview-container="${attrValue}"]`);
    }
    if (!container) return null;
    previewContainers.set(key, container);
    return {
      container,
      status: container.querySelector(`[data-preview-status="${attrValue}"]`),
      summary: container.querySelector(`[data-preview-summary="${attrValue}"]`),
      metadata: container.querySelector(`[data-preview-metadata="${attrValue}"]`),
      pipeline: container.querySelector(`[data-preview-pipeline="${attrValue}"]`),
      applyBtn: container.querySelector(`.apply-link[data-folder-id="${attrValue}"]`),
    };
  }

  function resetPreviewDisplay(folderId, hintElement) {
    const elements = getPreviewElements(folderId, hintElement);
    if (!elements) return;
    if (elements.status) {
      elements.status.textContent = "";
      elements.status.classList.remove("error");
    }
    if (elements.summary) {
      elements.summary.classList.add("hidden");
      elements.summary.innerHTML = "";
    }
    if (elements.metadata) {
      elements.metadata.classList.add("hidden");
      elements.metadata.innerHTML = "";
    }
    if (elements.pipeline) {
      elements.pipeline.classList.add("hidden");
      elements.pipeline.innerHTML = "";
    }
    if (elements.applyBtn) {
      elements.applyBtn.classList.add("hidden");
      elements.applyBtn.disabled = true;
      const label =
        elements.applyBtn.dataset.default || "Apply metadata and Box folder tagging";
      elements.applyBtn.textContent = label;
    }
    elements.container.classList.add("hidden");
  }

  function clearPreviewState(folderId, options = {}) {
    previewState.delete(folderId);
    previewContainers.delete(String(folderId ?? ""));
    const elements = getPreviewElements(folderId);
    if (!elements) return;
    if (elements.status) {
      elements.status.textContent = "";
      elements.status.classList.remove("error");
    }
    if (elements.summary) {
      elements.summary.classList.add("hidden");
      elements.summary.innerHTML = "";
    }
    if (elements.metadata) {
      elements.metadata.classList.add("hidden");
      elements.metadata.innerHTML = "";
    }
    if (elements.pipeline) {
      elements.pipeline.classList.add("hidden");
      elements.pipeline.innerHTML = "";
    }
    if (elements.applyBtn) {
      elements.applyBtn.classList.add("hidden");
      elements.applyBtn.disabled = true;
      const label =
        elements.applyBtn.dataset.default || "Apply metadata and Box folder tagging";
      elements.applyBtn.textContent = label;
    }
    if (elements.container) {
      if (options.keepVisible) {
        elements.container.classList.remove("hidden");
      } else {
        elements.container.classList.add("hidden");
      }
    }
  }

  function setPreviewStatus(folderId, message, isError = false) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.status) return;
    elements.status.textContent = message;
    if (isError) {
      elements.status.classList.add("error");
    } else {
      elements.status.classList.remove("error");
    }
  }

  function addPipelineStep(folderId, message, level = "info") {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.pipeline) return;
    elements.pipeline.classList.remove("hidden");
    const span = document.createElement("span");
    span.textContent = message;
    span.classList.add(`status-${level}`);
    elements.pipeline.appendChild(span);
  }

  function parseTimestamp(value) {
    if (!value && value !== 0) return 0;
    if (typeof value === "number") return value;
    const str = String(value).trim();
    if (!str) return 0;
    if (/^\d+$/.test(str)) {
      const num = Number(str);
      if (Number.isNaN(num)) return 0;
      return num > 1e12 ? num : num * 1000;
    }
    const parsed = Date.parse(str);
    return Number.isNaN(parsed) ? 0 : parsed;
  }

  function extractDealTimestamp(deal) {
    const props = (deal && deal.properties) || {};
    const candidates = [
      props.agreement_start_date,
      props.closedate,
      props.hs_closed_won_date,
      deal?.updatedAt,
      deal?.createdAt,
    ];
    for (const candidate of candidates) {
      const ts = parseTimestamp(candidate);
      if (ts) return ts;
    }
    return 0;
  }

  function formatDate(ts) {
    if (!ts) return "n/a";
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return "n/a";
    return d.toISOString().slice(0, 10);
  }

  function extractPortalIdFromUrl(url) {
    if (!url) return "";
    const match = String(url).match(/contacts\/(\d+)\/record/);
    return match ? match[1] : "";
  }

  function buildContactLink(portalId, contactId) {
    if (!portalId || !contactId) return undefined;
    return `https://app.hubspot.com/contacts/${portalId}/record/0-1/${contactId}`;
  }

  function formatAssociatedContact({ name, email, id, link }) {
    const parts = [];
    if (email) parts.push(email);
    if (id) parts.push(`ID: ${id}`);
    if (link) parts.push(`Link: ${link}`);
    if (!parts.length) return name || "Contact";
    return `${name || "Contact"} (${parts.join(" | ")})`;
  }

  function buildMetadataPreview(payload, deal, contact) {
    const primaryName = [payload.hs_contact_firstname, payload.hs_contact_lastname]
      .filter(Boolean)
      .join(" ")
      .trim();
    const spouseName = [payload.hs_spouse_firstname, payload.hs_spouse_lastname]
      .filter(Boolean)
      .join(" ")
      .trim();

    const portalId = extractPortalIdFromUrl(contact?.url);
    const primaryLink = contact?.url || buildContactLink(portalId, payload.hs_contact_id);
    const spouseLink = buildContactLink(portalId, payload.hs_spouse_id);

    const associatedIdSet = new Set();
    const associatedContacts = [];
    const seenContactKeys = new Set();

    const pushAssociatedContact = ({ name, email, id, link }) => {
      const trimmedId = (id || "").trim();
      const key = `${trimmedId}|${(email || name || "").toLowerCase()}`;
      if (key && seenContactKeys.has(key)) {
        return;
      }
      if (key) {
        seenContactKeys.add(key);
      }
      if (trimmedId) {
        associatedIdSet.add(trimmedId);
      }
      associatedContacts.push(
        formatAssociatedContact({
          name: name || "Contact",
          email: email || "",
          id: trimmedId,
          link,
        }),
      );
    };

    if (primaryName || payload.hs_contact_id || payload.hs_contact_email) {
      pushAssociatedContact({
        name: primaryName || "Primary Contact",
        email: payload.hs_contact_email || "",
        id: payload.hs_contact_id || "",
        link: primaryLink,
      });
    }
    if (spouseName || payload.hs_spouse_id || payload.hs_spouse_email) {
      pushAssociatedContact({
        name: spouseName || "Spouse",
        email: payload.hs_spouse_email || "",
        id: payload.hs_spouse_id || "",
        link: spouseLink,
      });
    }

    const metadataFields = {
      deal_salutation: payload.deal_salutation || "",
      household_type: payload.household_type || "",
      primary_contact_id: payload.hs_contact_id || "",
      primary_contact_link: primaryLink || "",
      hs_spouse_id: payload.hs_spouse_id || "",
      spouse_contact_link: spouseLink || "",
    };

    const dealDetails = (() => {
      if (!deal) return undefined;
      const props = deal.properties || {};
      return {
        id: props.hs_deal_record_id || deal.id || "",
        name: props.dealname || "",
        stage: props.dealstage || "",
        close_date: formatDate(extractDealTimestamp(deal)) || "",
      };
    })();

    return {
      folder_id: payload.folder_id,
      deal_id: payload.deal_id,
      deal: dealDetails,
      metadata_fields: metadataFields,
      contacts: {
        primary: {
          id: payload.hs_contact_id || "",
          name: primaryName || "",
          email: payload.hs_contact_email || "",
          link: primaryLink || "",
        },
        spouse: {
          id: payload.hs_spouse_id || "",
          name: spouseName || "",
          email: payload.hs_spouse_email || "",
          link: spouseLink || "",
          firstname: payload.hs_spouse_firstname || "",
          lastname: payload.hs_spouse_lastname || "",
        },
        additional: associatedContacts,
      },
    };
  }

  function buildContactSummary(contact) {
    if (!contact) {
      return "‚Äî";
    }
    const name =
      contact.name ||
      [contact.firstname, contact.lastname].filter(Boolean).join(" ").trim();
    const parts = [];
    if (name) {
      parts.push(`<strong>${escapeHtml(name)}</strong>`);
    }
    if (contact.email) {
      parts.push(`<span class="muted small">${escapeHtml(contact.email)}</span>`);
    }
    if (contact.id) {
      parts.push(`<span class="muted small">ID: ${escapeHtml(contact.id)}</span>`);
    }
    if (contact.link) {
      parts.push(
        `<a href="${escapeHtml(contact.link)}" target="_blank" rel="noopener">HubSpot</a>`,
      );
    }
    return parts.length ? parts.join("<br/>") : "‚Äî";
  }

  function isMetadataValueEmpty(value) {
    if (value === null || value === undefined) {
      return true;
    }
    if (typeof value === "string") {
      return value.trim() === "";
    }
    if (Array.isArray(value)) {
      return value.length === 0;
    }
    if (typeof value === "object") {
      return Object.keys(value).length === 0;
    }
    return false;
  }

  function formatMetadataValue(value) {
    if (
      value === null
      || value === undefined
      || (typeof value === "string" && value.trim() === "")
    ) {
      return '<span class="muted small">‚Äî</span>';
    }
    if (typeof value === "object") {
      try {
        const serialized = JSON.stringify(value, null, 2);
        return `<pre>${escapeHtml(serialized)}</pre>`;
      } catch (error) {
        return `<pre>${escapeHtml(String(value))}</pre>`;
      }
    }
    return escapeHtml(String(value));
  }

  function buildMetadataTableRows(fields) {
    const entries = Object.entries(fields || {}).filter(([, value]) => !isMetadataValueEmpty(value));
    if (!entries.length) {
      return '<tr><td colspan="2">No metadata fields populated.</td></tr>';
    }
    return entries
      .map(
        ([key, value]) =>
          `<tr><td>${escapeHtml(key)}</td><td>${formatMetadataValue(value)}</td></tr>`,
      )
      .join("");
  }

  function selectBestDeal(deals) {
    if (!Array.isArray(deals) || !deals.length) {
      return null;
    }
    const sorted = [...deals].sort(
      (a, b) => extractDealTimestamp(b) - extractDealTimestamp(a),
    );
    return sorted[0];
  }

  function buildBasePayload(folderId, contact, selectedDeal) {
    const payload = { folder_id: folderId };
    const dealProps = (selectedDeal && selectedDeal.properties) || {};
    const dealId = String(dealProps.hs_deal_record_id || selectedDeal?.id || "").trim();
    if (dealId) {
      payload.deal_id = dealId;
      payload.hs_deal_record_id = dealId;
    }
    const contactProps = (contact && contact.properties) || {};
    if (contact && contact.id) payload.hs_contact_id = contact.id;
    if (contactProps.firstname) payload.hs_contact_firstname = contactProps.firstname;
    if (contactProps.lastname) payload.hs_contact_lastname = contactProps.lastname;
    if (contactProps.email) payload.hs_contact_email = contactProps.email;
    if (dealProps.hs_spouse_id && !payload.hs_spouse_id) payload.hs_spouse_id = dealProps.hs_spouse_id;
    if (dealProps.hs_spouse_firstname && !payload.hs_spouse_firstname) payload.hs_spouse_firstname = dealProps.hs_spouse_firstname;
    if (dealProps.hs_spouse_lastname && !payload.hs_spouse_lastname) payload.hs_spouse_lastname = dealProps.hs_spouse_lastname;
    if (dealProps.hs_spouse_email && !payload.hs_spouse_email) payload.hs_spouse_email = dealProps.hs_spouse_email;
    if (dealProps.deal_salutation && !payload.deal_salutation) payload.deal_salutation = dealProps.deal_salutation;
    if (dealProps.household_type && !payload.household_type) payload.household_type = dealProps.household_type;

    return payload;
  }

  function buildPayloadForApply(basePayload, previewData) {
    const payload = { ...basePayload };
    const metadataFields = previewData?.metadata_fields || {};
    Object.entries(metadataFields).forEach(([key, value]) => {
      if (!isMetadataValueEmpty(value)) {
        payload[key] = value;
      }
    });
    return payload;
  }

  function renderPreviewSummary(folderId, previewData, deal, rootFolder) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.summary) return;
    const folderName = rootFolder?.name || rootFolder?.path || previewData.folder_id || folderId;
    const folderLink = rootFolder?.url
      ? `<a href="${escapeHtml(rootFolder.url)}" target="_blank" rel="noopener">${escapeHtml(folderName)}</a>`
      : escapeHtml(folderName);
    const contacts = previewData.contacts || {};
    const dealInfo = previewData.deal || {};
    const dealUrl = deal?.url;
    const dealLabel = escapeHtml(dealInfo.name || dealInfo.id || "n/a");
    const dealLink = dealUrl
      ? `<a href="${escapeHtml(dealUrl)}" target="_blank" rel="noopener">${dealLabel}</a>`
      : dealLabel;

    elements.summary.innerHTML = `
      <h4>Metadata preview</h4>
      <p><strong>Box folder:</strong> <span>${folderLink}</span></p>
      <p><strong>Primary contact:</strong> <span>${buildContactSummary(contacts.primary)}</span></p>
      <p><strong>Spouse:</strong> <span>${buildContactSummary(contacts.spouse)}</span></p>
      <p><strong>Deal:</strong> <span>${dealLink} ¬∑ Stage: ${escapeHtml(dealInfo.stage || "n/a")} ¬∑ Close: ${escapeHtml(dealInfo.close_date || "n/a")}</span></p>
    `;
    elements.summary.classList.remove("hidden");
  }

  function renderMetadataTable(folderId, metadataFields) {
    const elements = getPreviewElements(folderId);
    if (!elements || !elements.metadata) return;
    const rows = buildMetadataTableRows(metadataFields);
    elements.metadata.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
    elements.metadata.classList.remove("hidden");
  }

  async function loadPreviewForFolder(folderId, button) {
    const elements = getPreviewElements(folderId, button);
    if (!elements) return;
    previewState.delete(folderId);
    resetPreviewDisplay(folderId, button);
    elements.container.classList.remove("hidden");
    setPreviewStatus(folderId, "Preparing preview‚Ä¶");
    setBusy(button, true, "Loading‚Ä¶");
    const aggregatedAll = new Map();
    const aggregatedExternal = new Map();

    const registerCollaborator = (collab, contextLabel) => {
      if (!collab || !collab.email) return;
      const key = String(collab.email).trim().toLowerCase();
      if (!key) return;
      if (!aggregatedAll.has(key)) {
        aggregatedAll.set(key, { collab, context: contextLabel || "Folder" });
      }
      if (!key.endsWith(PIVOT_DOMAIN) && !aggregatedExternal.has(key)) {
        aggregatedExternal.set(key, { collab, context: contextLabel || "Folder" });
      }
    };

    const registerFromResponse = (data, contextLabel) => {
      const collaborators = Array.isArray(data?.collaborators) ? data.collaborators : [];
      collaborators.forEach((collab) => registerCollaborator(collab, contextLabel));
    };

    try {
      addPipelineStep(folderId, "Fetching collaborators‚Ä¶", "info");
      const collaboratorsData = await fetchJSON(
        `/box/folder/collaborators?folder_id=${encodeURIComponent(folderId)}&include_subfolders=1`,
      );
      addPipelineStep(folderId, "Root collaborators loaded", "success");
      registerFromResponse(collaboratorsData, "Root folder");

      const subfolders = Array.isArray(collaboratorsData.subfolders)
        ? collaboratorsData.subfolders
        : [];
      for (const sub of subfolders) {
        const label = sub.name || sub.id || "Subfolder";
        addPipelineStep(folderId, `Scanning subfolder ${label}‚Ä¶`, "info");
        try {
          const subData = await fetchJSON(
            `/box/folder/collaborators?folder_id=${encodeURIComponent(
              folderId,
            )}&subfolder_id=${encodeURIComponent(sub.id)}&subfolder=${encodeURIComponent(sub.name || "")}`,
          );
          registerFromResponse(subData, `Subfolder ${label}`);
          addPipelineStep(folderId, `Subfolder ${label} processed`, "success");
        } catch (error) {
          console.error(error);
          addPipelineStep(
            folderId,
            `Failed to scan subfolder ${label}: ${error.message}`,
            "error",
          );
        }
      }

      const externalList = Array.from(aggregatedExternal.values());
      const allList = Array.from(aggregatedAll.values());
      if (!externalList.length && allList.length) {
        addPipelineStep(
          folderId,
          "No external collaborators detected; using first available collaborator.",
          "info",
        );
      }
      const chosenRecord = externalList[0] || allList[0] || null;
      const chosen = chosenRecord?.collab || null;
      if (!chosen || !chosen.email) {
        setPreviewStatus(folderId, "Unable to generate preview ¬∑ no collaborators found.", true);
        addPipelineStep(folderId, "No collaborators returned", "error");
        return;
      }

      addPipelineStep(
        folderId,
        `Selected collaborator ${chosen.email}${chosenRecord?.context ? ` (${chosenRecord.context})` : ""}`,
        "info",
      );
      const contactData = await fetchJSON(
        `/box/collaborators/contact?email=${encodeURIComponent(chosen.email)}`,
      );
      addPipelineStep(folderId, "HubSpot contact loaded", "success");

      const deals = Array.isArray(contactData?.deals) ? contactData.deals : [];
      const selectedDeal = selectBestDeal(deals);
      if (!selectedDeal) {
        setPreviewStatus(folderId, "No associated deals found in HubSpot.", true);
        addPipelineStep(folderId, "No deals associated with contact", "error");
        return;
      }

      addPipelineStep(
        folderId,
        `Selected deal ${escapeHtml(selectedDeal.properties?.dealname || selectedDeal.id || "n/a")}`,
        "info",
      );

      const rootFolder = collaboratorsData.root_folder || {
        id: folderId,
        name: collaboratorsData?.inspected?.name || "",
        url: `https://app.box.com/folder/${folderId}`,
      };

      const basePayload = buildBasePayload(folderId, contactData.contact, selectedDeal);
      const previewData = buildMetadataPreview(basePayload, selectedDeal, contactData.contact);
      const finalPayload = buildPayloadForApply(basePayload, previewData);
      renderPreviewSummary(folderId, previewData, selectedDeal, rootFolder);
      renderMetadataTable(folderId, previewData.metadata_fields);

      const metadataFields = previewData.metadata_fields || {};
      const hasMetadataContent = Object.entries(metadataFields).some(
        ([, value]) => !isMetadataValueEmpty(value),
      );
      if (!hasMetadataContent) {
        addPipelineStep(folderId, "Metadata fields missing or blank", "error");
        setPreviewStatus(
          folderId,
          "Preview generated but metadata fields are incomplete.",
          true,
        );
        previewState.set(folderId, {
          folderId,
          basePayload,
          finalPayload,
          payload: finalPayload,
          previewData,
          contact: contactData.contact,
          deal: selectedDeal,
          rootFolder,
          collaborator: chosen,
        });
        return;
      }

      previewState.set(folderId, {
        folderId,
        basePayload,
        finalPayload,
        payload: finalPayload,
        previewData,
        contact: contactData.contact,
        deal: selectedDeal,
        rootFolder,
        collaborator: chosen,
      });
      setPreviewStatus(folderId, "Preview ready. Review and apply when ready.");
      addPipelineStep(folderId, "Metadata preview generated", "success");

      if (elements.applyBtn) {
        elements.applyBtn.classList.remove("hidden");
        elements.applyBtn.disabled = false;
        elements.applyBtn.dataset.default = elements.applyBtn.dataset.default || elements.applyBtn.textContent;
      }
    } catch (error) {
      console.error(error);
      setPreviewStatus(folderId, `Preview failed ¬∑ ${error.message}`, true);
      addPipelineStep(folderId, error.message, "error");
    } finally {
      setBusy(button, false);
    }
  }

  async function applyMetadataForFolder(folderId, button) {
    const state = previewState.get(folderId);
    const elements = getPreviewElements(folderId, button);
    if (!state) {
      setPreviewStatus(folderId, "Generate preview before applying metadata.", true);
      return;
    }
    const finalPayload =
      state.finalPayload
      || state.payload
      || (state.basePayload && state.previewData
        ? buildPayloadForApply(state.basePayload, state.previewData)
        : null);
    if (!finalPayload) {
      setPreviewStatus(folderId, "Preview payload is unavailable; regenerate preview.", true);
      return;
    }
    const defaultLabel = button ? (button.dataset.default || button.textContent) : "";
    if (button) {
      button.dataset.default = defaultLabel;
      button.textContent = "Applying‚Ä¶";
      button.disabled = true;
    }
    setPreviewStatus(folderId, "Applying metadata and updating HubSpot‚Ä¶");
    addPipelineStep(folderId, "Applying metadata via API‚Ä¶", "info");
    try {
      const response = await fetchJSON("/box/folder/tag/auto", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(finalPayload),
      });
      addPipelineStep(folderId, "Metadata applied in Box", "success");
      addPipelineStep(folderId, "HubSpot update completed", "success");
      setPreviewStatus(
        folderId,
        `Metadata applied successfully to folder ${escapeHtml(response.folder_id)}.`,
      );
      if (button) {
        button.dataset.default = "Metadata applied";
        button.textContent = "Metadata applied";
        button.disabled = true;
      }
    } catch (error) {
      console.error(error);
      setPreviewStatus(folderId, `Apply failed ¬∑ ${error.message}`, true);
      addPipelineStep(folderId, error.message, "error");
      if (button) {
        button.disabled = false;
        button.textContent = defaultLabel || "Apply metadata and Box folder tagging";
      }
      return;
    } finally {
      if (button && !button.disabled) {
        button.textContent = button.dataset.default || defaultLabel || button.textContent;
      }
    }
  }

  document.querySelectorAll(".preview-link").forEach((button) => {
    button.addEventListener("click", () => {
      const folderId = button.dataset.folderId;
      if (!folderId) return;
      loadPreviewForFolder(folderId, button);
    });
  });

  document.querySelectorAll(".apply-link").forEach((button) => {
    button.addEventListener("click", () => {
      const folderId = button.dataset.folderId;
      if (!folderId) return;
      applyMetadataForFolder(folderId, button);
    });
  });
</script>
{% endblock %}
